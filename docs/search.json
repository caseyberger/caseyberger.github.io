[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Casey E Berger",
    "section": "",
    "text": "Assistant Professor\nPhysics and Statistical and Data Sciences\nSmith College"
  },
  {
    "objectID": "index.html#interdisciplinary-science",
    "href": "index.html#interdisciplinary-science",
    "title": "Casey E Berger",
    "section": "Interdisciplinary Science",
    "text": "Interdisciplinary Science\nLife is more interesting on the boundaries!"
  },
  {
    "objectID": "cv_and_pubs.html",
    "href": "cv_and_pubs.html",
    "title": "CV and Publications",
    "section": "",
    "text": "CV\nMy up-to-date academic CV as of August 2023 can be found here\n\n\nAcademic Publications"
  },
  {
    "objectID": "inclusive_classroom.html",
    "href": "inclusive_classroom.html",
    "title": "Building an Inclusive Classroom",
    "section": "",
    "text": "How can you be sure students of all backgrounds feel comfortable in your class?"
  },
  {
    "objectID": "teaching_philosophy.html",
    "href": "teaching_philosophy.html",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Traditional lecture-heavy lesson planning is not the most effective way to facilitate student learning. My teaching philosophy incorporates research-backed methods to help students build efficacy and cultivate a set of tools they can use beyond my classroom.\nUsing research-backed methods in the classroom takes time and effort. It’s challenging, and there are lots of barriers to implementation. But it’s worth it.\n\n\nLearning is an active process. If I stand in front of the classroom and deliver a perfect lecture, the best case is that students will absorb the information I’ve provided and be able to regurgitate it later on an exam. But this style of teaching gives the students no opportunities to practice applying that information. Active learning improves retention of knowledge, and it facilitates the acquisition of a deeper understanding: not just a memorization of facts, but an ability to apply the knowledge in more complex ways.\nActive learning is effective not only at the introductory level, but also in advanced graduate coursework.\n\n\n\nStudents benefit greatly from working with their peers. Those who may need a little extra support are able to watch their peers model their thinking process and are likely to share the same questions, which reinforces a growth mindset. Students who are already on top of the material benefit as well, as walking a peer through how they arrived at the answer strengthens their own understanding of the concept and can help reveal nuance. Groups should be kept small enough that all students are able to contribute, but large enough to balance out possible power dynamics. The most successful groups have been shown to be around 3-5 students.\nBut the community is not just between students and their peers: it includes the instructor as well. My practice is to trust my students and to work with them on an individual level. We are all still learning how to learn (even those of us who have been doing this a long time), and taking ownership of your own education is far more valuable than performing well in a classroom with rigid expectations. The trust between student and instructor takes time to develop, but it’s essential to supporting students in a way that prepares them for the world outside the classroom.\n\n\n\nShort-term memory is extremely limited. The human brain is built to process information, but it can only handle so much at one time. Every embellishment – from complicated visuals to interesting side stories – steals attention away from the concepts being presented and minimizing the ability of students to absorb the information.\n\n\n\nJargon is a useful shorthand. But in order for the shorthand to be effective, the people using the jargon need to understand the underlying concepts.\nJargon is for experts, not learners. Introducing shorthand words – even if they are standard in the field – only obfuscates the concepts.\n\n\n\nIf students feel unsafe or like they don’t belong, their ability to learn and grow will be limited.\nThere are many things you can do to make your classroom safer and more inclusive."
  },
  {
    "objectID": "teaching_philosophy.html#active-learning",
    "href": "teaching_philosophy.html#active-learning",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Learning is an active process. If I stand in front of the classroom and deliver a perfect lecture, the best case is that students will absorb the information I’ve provided and be able to regurgitate it later on an exam. But this style of teaching gives the students no opportunities to practice applying that information. Active learning improves retention of knowledge, and it facilitates the acquisition of a deeper understanding: not just a memorization of facts, but an ability to apply the knowledge in more complex ways.\nActive learning is effective not only at the introductory level, but also in advanced graduate coursework."
  },
  {
    "objectID": "teaching_philosophy.html#building-community",
    "href": "teaching_philosophy.html#building-community",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Students benefit greatly from working with their peers. Those who may need a little extra support are able to watch their peers model their thinking process and are likely to share the same questions, which reinforces a growth mindset. Students who are already on top of the material benefit as well, as walking a peer through how they arrived at the answer strengthens their own understanding of the concept and can help reveal nuance. Groups should be kept small enough that all students are able to contribute, but large enough to balance out possible power dynamics. The most successful groups have been shown to be around 3-5 students.\nBut the community is not just between students and their peers: it includes the instructor as well. My practice is to trust my students and to work with them on an individual level. We are all still learning how to learn (even those of us who have been doing this a long time), and taking ownership of your own education is far more valuable than performing well in a classroom with rigid expectations. The trust between student and instructor takes time to develop, but it’s essential to supporting students in a way that prepares them for the world outside the classroom."
  },
  {
    "objectID": "teaching_philosophy.html#reducing-distractions",
    "href": "teaching_philosophy.html#reducing-distractions",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Short-term memory is extremely limited. The human brain is built to process information, but it can only handle so much at one time. Every embellishment – from complicated visuals to interesting side stories – steals attention away from the concepts being presented and minimizing the ability of students to absorb the information."
  },
  {
    "objectID": "teaching_philosophy.html#concepts-first-jargon-later",
    "href": "teaching_philosophy.html#concepts-first-jargon-later",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Jargon is a useful shorthand. But in order for the shorthand to be effective, the people using the jargon need to understand the underlying concepts.\nJargon is for experts, not learners. Introducing shorthand words – even if they are standard in the field – only obfuscates the concepts."
  },
  {
    "objectID": "teaching_philosophy.html#safe-and-inclusive-classrooms",
    "href": "teaching_philosophy.html#safe-and-inclusive-classrooms",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "If students feel unsafe or like they don’t belong, their ability to learn and grow will be limited.\nThere are many things you can do to make your classroom safer and more inclusive."
  },
  {
    "objectID": "bio.html",
    "href": "bio.html",
    "title": "About Me",
    "section": "",
    "text": "Academic Bio\nI am an assistant professor of physics and statistical and data sciences at Smith College. Previously, I was a postdoctoral research associate at Boston University in the physics department and the Hariri Institute for Computing. I earned my PhD from the University of North Carolina at Chapel Hill, where I was a Department of Energy Computational Science Graduate Fellow and a William Neal Reynolds fellow in the Royster Society of Fellows. My research is in computational and data science methods in many-body quantum mechanics.\n\nI also work on issues of diversity and equity in STEM, with an emphasis on improving representation and support of women, LGBTQ folks, BIPOC, and other underrepresented groups in STEM. When I’m not working in STEM and STEM-related pursuits, you can find me running, cooking, practicing photography, or writing."
  },
  {
    "objectID": "python_data_science.html",
    "href": "python_data_science.html",
    "title": "Teaching Data Science to Physics Students",
    "section": "",
    "text": "So you want to teach your physics students some data science?\nFortunately, there are lots of resources to help you do just this! I’ve put together a handy guide that should help walk you through this process, whether you’re just hearing the words “Python programming language” for the first time or a seasoned pro.\nIf you are completely new to Python, you should start with The Basics of Python, where I walk through a basic Python bootcamp and provide links to other resources for practice.\n\nGetting StartedReady to Dive InDig Deeper\n\n\nIn this section are a number of resources to help walk you through some of the most widely-used (and accessible) tools for programming in the classroom. There, you can learn some basic Python, get comfortable with a free and easy to use (no downloads or installs required!) coding environment, and get some best practices tips for teaching students who are also just getting started.\nIf you don’t already have Python installed on your machine, or if you don’t already have access to a cloud-based programming environment (like JupyterHub or Posit), this notebook will walk you through Google Colab, which is an excellent, free option if you want to program with Python and don’t want to have to install a bunch of programs on your computer. All you need to start this process is a Google account.\nThis tutorial will walk you through the basics of Colab. Click on this link, and it should take you to a page that looks like this:\n\n\nIn this section, you can find modules developed by graduate and postdoctoral fellows in the Data Science Education Community of Practice (DSECOP), part of the American Physical Society’s topical Group on Data Science. These modules are designed to fit into physics courses and can be adapted for students at varying levels of coding ability\n\n\nIn this section, you will find more modules by the DSECOP fellows, which are intended for more advanced students. Once students have gained some familiarity with data science tools and processes (using the earlier modules, for example), they will be ready for these modules."
  },
  {
    "objectID": "python_data_science.html#python-basics",
    "href": "python_data_science.html#python-basics",
    "title": "Teaching Python and Data Science to Physics Students",
    "section": "Python basics",
    "text": "Python basics"
  },
  {
    "objectID": "python_data_science.html#using-google-colab",
    "href": "python_data_science.html#using-google-colab",
    "title": "Teaching Python and Data Science to Physics Students",
    "section": "Using Google colab",
    "text": "Using Google colab\nIf you don’t already have Python installed on your machine, or if you don’t already have access to a cloud-based programming environment (like JupyterHub or Posit), this notebook will walk you through Google Colab, which is an excellent, free option if you want to program with Python and don’t want to have to install a bunch of programs on your computer. All you need to start this process is a Google account.\nThis tutorial will walk you through the basics of Colab. Click on this link, and it should take you to a page that looks like this:"
  },
  {
    "objectID": "beginning_python.html",
    "href": "beginning_python.html",
    "title": "Beginning Python",
    "section": "",
    "text": "If you’re brand new to Python, this page will walk you through everything from installation to basic Python syntax. You can also find a list of Additional References for more detail and opportunities to practice.\n\nShould I install Python or use a cloud-based environment?\nThis depends on your own needs. If you want to be able to work offline, then you’ll want to install Python on your local machine. But if you can reliably expect access to the internet, then an online service will be a lot quicker to start with and will prevent the need to manage updates, install special packages, or deal with software incompatibilities.\nIn both cases, I recommend working with Jupyter notebooks to begin. A Jupyter notebook allows you to run code in small chunks as well as leave clear notes and documentation throughout. If you have worked with Posit or RStudio, you will already be familiar with how this works. If you haven’t, don’t worry! We will walk through it below.\n\nInstalling Python and JupyterLabAccessing Google Colab\n\n\n\n\n\n\n\n\n\n\n\nUsing a Notebook (Jupyter or Colab)\n\n\nAdditional References\nPython’s guide to Python for Beginners"
  },
  {
    "objectID": "beginning_python.html#should-i-install-python-or-use-a-cloud-based-environment",
    "href": "beginning_python.html#should-i-install-python-or-use-a-cloud-based-environment",
    "title": "Beginning Python",
    "section": "Should I install Python or use a cloud-based environment?",
    "text": "Should I install Python or use a cloud-based environment?\nThis depends on your own needs. If you want to be able to work offline, then you’ll want to install Python on your local machine. But if you can reliably expect access to the internet, then an online service will be a lot quicker to start with and will prevent the need to manage updates, install special packages, or deal with software incompatibilities.\nIn both cases, I recommend working with Jupyter notebooks to begin. A Jupyter notebook allows you to run code in small chunks as well as leave clear notes and documentation throughout. If you have worked with Posit or RStudio, you will already be familiar with how this works. If you haven’t, don’t worry! We will walk through it below.\n\nInstalling Python and JupyterLabAccessing Google Colab"
  },
  {
    "objectID": "beginning_python.html#additional-references",
    "href": "beginning_python.html#additional-references",
    "title": "Beginning Python",
    "section": "Additional References",
    "text": "Additional References\nPython’s guide to Python for Beginners"
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html",
    "href": "SDS271/F23/Lab1_clean.html",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "This introductory lab will serve as a refresher on the Python skills you learned in previous classes, as well as a chance to get to know the course structure and content.\nYou can download the .ipynb for this lab here, or you can find it in Moodle.\n\n\nFor the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!\n\n\n\n\n\nIf you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report here\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes.\n\n\n\n\n\nOne of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function.\n\n\n\n\n\nPython can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words.\n\n\n\n\nAnother way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this.\n\n\n\n\nA central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list[\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth"
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#a-note-on-the-labs",
    "href": "SDS271/F23/Lab1_clean.html#a-note-on-the-labs",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "For the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!"
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#part-one-jupyterhub",
    "href": "SDS271/F23/Lab1_clean.html#part-one-jupyterhub",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "If you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report here\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#part-two-python-refresher-and-syllabus-activity",
    "href": "SDS271/F23/Lab1_clean.html#part-two-python-refresher-and-syllabus-activity",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "One of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#lists",
    "href": "SDS271/F23/Lab1_clean.html#lists",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "Python can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#dictionaries",
    "href": "SDS271/F23/Lab1_clean.html#dictionaries",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "Another way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#loops-and-functions",
    "href": "SDS271/F23/Lab1_clean.html#loops-and-functions",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "A central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list[\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth"
  },
  {
    "objectID": "SDS271/F23/sds-271-f23-homepage.html",
    "href": "SDS271/F23/sds-271-f23-homepage.html",
    "title": "SDS 271 Fall 2023",
    "section": "",
    "text": "Welcome to the Fall 2023 version of SDS 271: Advanced Programming for Data Science in Python!"
  },
  {
    "objectID": "sds-271-f23-homepage.html",
    "href": "sds-271-f23-homepage.html",
    "title": "SDS 271 Fall 2023",
    "section": "",
    "text": "Welcome to the Fall 2023 version of SDS 271: Advanced Programming for Data Science in Python!"
  },
  {
    "objectID": "sds-271-f23-homepage.html#syllabus-and-schedule",
    "href": "sds-271-f23-homepage.html#syllabus-and-schedule",
    "title": "SDS 271 Fall 2023",
    "section": "Syllabus and Schedule",
    "text": "Syllabus and Schedule\nThe course syllabus can be found here.\n\nThe course schedule can be found here. It will be updated regularly and is subject to change."
  },
  {
    "objectID": "sds-271-f23-homepage.html#accessing-compute-resources-and-reporting-issues",
    "href": "sds-271-f23-homepage.html#accessing-compute-resources-and-reporting-issues",
    "title": "SDS 271 Fall 2023",
    "section": "Accessing Compute Resources and Reporting Issues",
    "text": "Accessing Compute Resources and Reporting Issues\nYou can access the Smith JupyterHub server here. You will need to log in with your Smith credentials. If you are off-campus, you will have to log into a VPN to get access.\n\nInstructions on how to install the Pulse Secure VPN can be found [on the Smith website] (https://www.smith.edu/its/tara/networking/vpn.html). You need to log in to the VPN with your Smith credentials before accessing JupyterHub. Once you’ve signed in (and done the Duo push), you should be able to access the server as normal.\n\nIf you have a bug or connection issue to report, you can do so here."
  },
  {
    "objectID": "sds-271-f23-homepage.html#providing-feedback",
    "href": "sds-271-f23-homepage.html#providing-feedback",
    "title": "SDS 271 Fall 2023",
    "section": "Providing Feedback",
    "text": "Providing Feedback\nIf you have feedback for me that you are not comfortable sharing directly but would like me to take into acocunt, please don’t hesitate to leave it here. This form is entirely anonymous – the only information I ask for is the class that this is about."
  },
  {
    "objectID": "sds-271-f23-homepage.html#lab-1",
    "href": "sds-271-f23-homepage.html#lab-1",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 1",
    "text": "Lab 1\nLab 1 is all about getting started with JupyterHub and reviewing your previous Python experience.\nYou can find the .ipynb for this lab in Moodle, or at this link if you’d prefer to use Google colab."
  },
  {
    "objectID": "sds-271-f23-homepage.html#textbook",
    "href": "sds-271-f23-homepage.html#textbook",
    "title": "SDS 271 Fall 2023",
    "section": "Textbook",
    "text": "Textbook\nThe textbook is Python for Data Analysis, 3rd edition, and is available for free online."
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html",
    "href": "SDS271/F23/Lab2_clean.html",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "This lab will dig a little more deeply into your previous Python experience as we examine two case studies in statistical simulations: the Monty Hall Problem and why the House always wins in gambling.\n\n\nWhat do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n\n\n\n\nMonte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nLet’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nLest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: \n\nStarting funds:\n\n\nWager amount: 100\n\n\nNumber of bets : 5\n\n\nScenario 2: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10\n\n\nScenario 3: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 100\n\n\nScenario 4: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10000\n\n\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#a-simple-scenario-flipping-a-coin",
    "href": "SDS271/F23/Lab2_clean.html#a-simple-scenario-flipping-a-coin",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "What do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#monte-carlo-methods",
    "href": "SDS271/F23/Lab2_clean.html#monte-carlo-methods",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "Monte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#the-monty-hall-problem",
    "href": "SDS271/F23/Lab2_clean.html#the-monty-hall-problem",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "Let’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#why-the-house-always-wins",
    "href": "SDS271/F23/Lab2_clean.html#why-the-house-always-wins",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "Lest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)"
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#the-simulation",
    "href": "SDS271/F23/Lab2_clean.html#the-simulation",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "We need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: \n\nStarting funds:\n\n\nWager amount: 100\n\n\nNumber of bets : 5\n\n\nScenario 2: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10\n\n\nScenario 3: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 100\n\n\nScenario 4: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10000\n\n\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "sds-271-f23-homepage.html#lab-2",
    "href": "sds-271-f23-homepage.html#lab-2",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 2",
    "text": "Lab 2\nLab 2 gives you a chance to dig deeper into Python; learn how to import and use Python packages like random, matplotlib, and numpy; and apply your previous statistical knowledge to explore the dangers of making uninformed wagers."
  },
  {
    "objectID": "sds-271-f23-homepage.html#office-hours",
    "href": "sds-271-f23-homepage.html#office-hours",
    "title": "SDS 271 Fall 2023",
    "section": "Office Hours",
    "text": "Office Hours\nMondays 10AM-11AM and Tuesdays 1PM-2PM, McConnell 214\n\nOr by appointment: www.calendly.com/caseyberger"
  },
  {
    "objectID": "sds-271-f23.html",
    "href": "sds-271-f23.html",
    "title": "SDS 271 Fall 2023",
    "section": "",
    "text": "Welcome to the Fall 2023 version of SDS 271: Programming for Data Science in Python!"
  },
  {
    "objectID": "sds-271-f23.html#textbook",
    "href": "sds-271-f23.html#textbook",
    "title": "SDS 271 Fall 2023",
    "section": "Textbook",
    "text": "Textbook\nThe textbook is Python for Data Analysis, 3rd edition, and is available for free online."
  },
  {
    "objectID": "sds-271-f23.html#syllabus-and-schedule",
    "href": "sds-271-f23.html#syllabus-and-schedule",
    "title": "SDS 271 Fall 2023",
    "section": "Syllabus and Schedule",
    "text": "Syllabus and Schedule\nThe course syllabus can be found here.\n\nThe course schedule can be found here. It will be updated regularly and is subject to change."
  },
  {
    "objectID": "sds-271-f23.html#office-hours",
    "href": "sds-271-f23.html#office-hours",
    "title": "SDS 271 Fall 2023",
    "section": "Office Hours",
    "text": "Office Hours\nMondays 10AM-11AM and Tuesdays 1PM-2PM, McConnell 214\n\nOr by appointment (link in Moodle)"
  },
  {
    "objectID": "sds-271-f23.html#accessing-compute-resources-and-reporting-issues",
    "href": "sds-271-f23.html#accessing-compute-resources-and-reporting-issues",
    "title": "SDS 271 Fall 2023",
    "section": "Accessing Compute Resources and Reporting Issues",
    "text": "Accessing Compute Resources and Reporting Issues\nYou can access the Smith JupyterHub server here. You will need to log in with your Smith credentials. If you are off-campus, you will have to log into a VPN to get access.\n\nInstructions on how to install the Pulse Secure VPN can be found [on the Smith website] (https://www.smith.edu/its/tara/networking/vpn.html). You need to log in to the VPN with your Smith credentials before accessing JupyterHub. Once you’ve signed in (and done the Duo push), you should be able to access the server as normal.\n\nIf you have a bug or connection issue to report, you can do so here."
  },
  {
    "objectID": "sds-271-f23.html#providing-feedback",
    "href": "sds-271-f23.html#providing-feedback",
    "title": "SDS 271 Fall 2023",
    "section": "Providing Feedback",
    "text": "Providing Feedback\nIf you have feedback for me that you are not comfortable sharing directly but would like me to take into acocunt, please don’t hesitate to leave it here. This form is entirely anonymous – the only information I ask for is the class that this is about."
  },
  {
    "objectID": "sds-271-f23.html#lab-1",
    "href": "sds-271-f23.html#lab-1",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 1",
    "text": "Lab 1\nLab 1 is all about getting started with JupyterHub and reviewing your previous Python experience.\nYou can find the .ipynb for this lab in Moodle, or at this link.\nLab 1 solutions"
  },
  {
    "objectID": "sds-271-f23.html#lab-2",
    "href": "sds-271-f23.html#lab-2",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 2",
    "text": "Lab 2\nLab 2 gives you a chance to dig deeper into Python; learn how to import and use Python packages like random, matplotlib, and numpy; and apply your previous statistical knowledge to explore the dangers of making uninformed wagers.\nLab 2 Solutions"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html",
    "href": "SDS271/F23/Lab2_solutions_09_12.html",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "This lab will dig a little more deeply into your previous Python experience as we examine two case studies in statistical simulations: the Monty Hall Problem and why the House always wins in gambling.\n\n\nWhat do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n&lt;li&gt; Pick randomly from a list of \"heads\" and \"tails\" &lt;/li&gt;\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n5\n4\n3\n1\n5\n3\n1\n4\n2\n3\nfor n in range(10):\n    print(rd.randint(1,6))\n3\n1\n1\n6\n6\n3\n3\n4\n2\n5\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\ntails\nheads\nheads\ntails\nheads\ntails\nheads\ntails\ncoin_list[0]\n'heads'\nfor n in range(10):\n    r = rd.randint(0,1)\n    print(coin_list[r])\nheads\nheads\ntails\ntails\nheads\ntails\ntails\ntails\ntails\ntails\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\nheads\ntails\nheads\ntails\ntails\nheads\nheads\nheads\ntails\ntails\nheads\nheads\ntails\ntails\ntails\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.3, 'tails': 0.7}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n\nStop here for a minute. Check-in with sli.do and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nMonte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.85, 'tails': 0.15}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nLet’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nLest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#a-simple-scenario-flipping-a-coin",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#a-simple-scenario-flipping-a-coin",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "What do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n&lt;li&gt; Pick randomly from a list of \"heads\" and \"tails\" &lt;/li&gt;\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n5\n4\n3\n1\n5\n3\n1\n4\n2\n3\nfor n in range(10):\n    print(rd.randint(1,6))\n3\n1\n1\n6\n6\n3\n3\n4\n2\n5\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\ntails\nheads\nheads\ntails\nheads\ntails\nheads\ntails\ncoin_list[0]\n'heads'\nfor n in range(10):\n    r = rd.randint(0,1)\n    print(coin_list[r])\nheads\nheads\ntails\ntails\nheads\ntails\ntails\ntails\ntails\ntails\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\nheads\ntails\nheads\ntails\ntails\nheads\nheads\nheads\ntails\ntails\nheads\nheads\ntails\ntails\ntails\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.3, 'tails': 0.7}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n\nStop here for a minute. Check-in with sli.do and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#monte-carlo-methods",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#monte-carlo-methods",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Monte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.85, 'tails': 0.15}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#the-monty-hall-problem",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#the-monty-hall-problem",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Let’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#why-the-house-always-wins",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#why-the-house-always-wins",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Lest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#the-simulation",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#the-simulation",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "We need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html",
    "href": "SDS271/F23/Lab1_solutions.html",
    "title": "Welcome to SDS 271!",
    "section": "",
    "text": "This introductory lab will serve as a refresher on the Python skills you learned in previous classes, as well as a chance to get to know the course structure and content.\n\n\nFor the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!\n\n\n\n\n\nIf you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report &lt;a href=\"https://forms.gle/FfBe5VvMCgqHy5Vi6\"&gt;here&lt;/a&gt;.\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n# solution\n1 + 1\n2\n//solution\nI used a cell to evaluate 1 + 1 and got the output 2, as expected.\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n#solution\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\n    x += 1\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes.\n\n\n\n\n\nOne of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\n# solution\ncourse_num = 271\ninstructor = \"Casey\"\ninst_email = \"cberger@smith.edu\"\nclass_len_hours = 1.25\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n#solution\nprint(type(course_num))\nprint(type(instructor))\nprint(type(inst_email))\nprint(type(class_len_hours))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'str'&gt;\n&lt;class 'float'&gt;\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function.\n\n\n\n\n\nPython can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words.\n\n#solution\ncourse_objectives = [\"write your own functions and packages in Python\",\n                    \"utilize class structures in Python to create reproducible, organized processes for data manupulation\",\n                    \"understand when to use functions and when to use classes\", \"submit a pull request to GitHub\",\n                    \"create clear and helpful documentation for your code\", \n                     \"use the Pandas library to organize, manage, and manipulate data\",\n                    \"explore a dataset visually with seaborn\",\n                    \"tell a story with data through effective visualizations\",\n                     \"write a complete Python package\"]\n\n\n\nAnother way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\n# solution\ngrades = {\"Labs\":0.2,\"Project 1\": 0.1, \"Project 2\": 0.15, \"Pull request\":0.05, \"Final Project\": 0.5 }\ngrades[\"Project 2\"]\n0.15\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this.\n\n#solution\ngrades_detailed = {\n    \"Labs\":{\n        \"due\": \"Wednesdays\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"S/U\"\n    },\n    \"Project 1\":{\n        \"due\": \"9/19\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    }, \n    \"Project 2\": {\n        \"due\": \"11/7\",\n        \"grade fraction\":0.15,\n        \"grade type\": \"S/U\"\n    }, \n    \"Pull request\":{\n        \"due\": \"10/31\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    }, \n    \"Final Project Pitch\": {\n        \"due\": \"10/5\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project proposal\":{\n        \"due\": \"10/19\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project rough draft\":{\n        \"due\": \"11/16\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project final draft\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"numerical\"\n    },\n    \"Final project assessments\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"numerical\"\n    }\n}\ngrades_detailed[\"Final project assessments\"]['grade fraction']\n0.1\n\n\n\nA central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list = [\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n# solution\nfor objective in course_objectives:\n    print(objective)\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n# solution\nnum_objectives = len(course_objectives)\ncount = 0\nwhile count &lt; num_objectives:\n    print(course_objectives[count])\n    count +=1\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth\n\n\n\n#solution\ndef what_percent(component, grade_dict):\n    grade_percent = (grade_dict[component]['grade fraction'])\n    return grade_percent\n#solution\nfp_grade = what_percent(\"Final project final draft\",grades_detailed)\nfp_grade\n0.2\n#solution\ndef when_is_this_due(component, grade_dict):\n    due_date = grade_dict[component]['due']\n    print(component+\" is due on \"+due_date)\n#solution\nwhen_is_this_due(\"Final project final draft\",grades_detailed)\nFinal project final draft is due on 12/14"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#a-note-on-the-labs",
    "href": "SDS271/F23/Lab1_solutions.html#a-note-on-the-labs",
    "title": "Welcome to SDS 271!",
    "section": "",
    "text": "For the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#part-one-jupyterhub",
    "href": "SDS271/F23/Lab1_solutions.html#part-one-jupyterhub",
    "title": "Welcome to SDS 271!",
    "section": "",
    "text": "If you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report &lt;a href=\"https://forms.gle/FfBe5VvMCgqHy5Vi6\"&gt;here&lt;/a&gt;.\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n# solution\n1 + 1\n2\n//solution\nI used a cell to evaluate 1 + 1 and got the output 2, as expected.\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n#solution\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\n    x += 1\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes."
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#part-two-python-refresher-and-syllabus-activity",
    "href": "SDS271/F23/Lab1_solutions.html#part-two-python-refresher-and-syllabus-activity",
    "title": "Welcome to SDS 271!",
    "section": "",
    "text": "One of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\n# solution\ncourse_num = 271\ninstructor = \"Casey\"\ninst_email = \"cberger@smith.edu\"\nclass_len_hours = 1.25\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n#solution\nprint(type(course_num))\nprint(type(instructor))\nprint(type(inst_email))\nprint(type(class_len_hours))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'str'&gt;\n&lt;class 'float'&gt;\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function."
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#lists",
    "href": "SDS271/F23/Lab1_solutions.html#lists",
    "title": "Welcome to SDS 271!",
    "section": "",
    "text": "Python can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words.\n\n#solution\ncourse_objectives = [\"write your own functions and packages in Python\",\n                    \"utilize class structures in Python to create reproducible, organized processes for data manupulation\",\n                    \"understand when to use functions and when to use classes\", \"submit a pull request to GitHub\",\n                    \"create clear and helpful documentation for your code\", \n                     \"use the Pandas library to organize, manage, and manipulate data\",\n                    \"explore a dataset visually with seaborn\",\n                    \"tell a story with data through effective visualizations\",\n                     \"write a complete Python package\"]"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#dictionaries",
    "href": "SDS271/F23/Lab1_solutions.html#dictionaries",
    "title": "Welcome to SDS 271!",
    "section": "",
    "text": "Another way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\n# solution\ngrades = {\"Labs\":0.2,\"Project 1\": 0.1, \"Project 2\": 0.15, \"Pull request\":0.05, \"Final Project\": 0.5 }\ngrades[\"Project 2\"]\n0.15\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this.\n\n#solution\ngrades_detailed = {\n    \"Labs\":{\n        \"due\": \"Wednesdays\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"S/U\"\n    },\n    \"Project 1\":{\n        \"due\": \"9/19\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    }, \n    \"Project 2\": {\n        \"due\": \"11/7\",\n        \"grade fraction\":0.15,\n        \"grade type\": \"S/U\"\n    }, \n    \"Pull request\":{\n        \"due\": \"10/31\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    }, \n    \"Final Project Pitch\": {\n        \"due\": \"10/5\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project proposal\":{\n        \"due\": \"10/19\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project rough draft\":{\n        \"due\": \"11/16\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project final draft\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"numerical\"\n    },\n    \"Final project assessments\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"numerical\"\n    }\n}\ngrades_detailed[\"Final project assessments\"]['grade fraction']\n0.1"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#loops-and-functions",
    "href": "SDS271/F23/Lab1_solutions.html#loops-and-functions",
    "title": "Welcome to SDS 271!",
    "section": "",
    "text": "A central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list = [\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n# solution\nfor objective in course_objectives:\n    print(objective)\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n# solution\nnum_objectives = len(course_objectives)\ncount = 0\nwhile count &lt; num_objectives:\n    print(course_objectives[count])\n    count +=1\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth\n\n\n\n#solution\ndef what_percent(component, grade_dict):\n    grade_percent = (grade_dict[component]['grade fraction'])\n    return grade_percent\n#solution\nfp_grade = what_percent(\"Final project final draft\",grades_detailed)\nfp_grade\n0.2\n#solution\ndef when_is_this_due(component, grade_dict):\n    due_date = grade_dict[component]['due']\n    print(component+\" is due on \"+due_date)\n#solution\nwhen_is_this_due(\"Final project final draft\",grades_detailed)\nFinal project final draft is due on 12/14"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html",
    "href": "SDS271/F23/Lab2_solutions.html",
    "title": "SDS 271 Lab 2: Statistics and Betting",
    "section": "",
    "text": "This lab will dig a little more deeply into your previous Python experience as we examine two case studies in statistical simulations: the Monty Hall Problem and why the House always wins in gambling.\n\n\nWhat do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n1\n6\n4\n5\n3\n2\n3\n5\n1\n3\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\nheads\nheads\ntails\ntails\ntails\ntails\nheads\nheads\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\ntails\ntails\nheads\ntails\ntails\ntails\nheads\nheads\nheads\ntails\nheads\nheads\nheads\nheads\nheads\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.5, 'tails': 0.5}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.35, 'tails': 0.65}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nMonte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.5, 'tails': 0.5}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands -- it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\n#solution\nimport numpy as np\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\n#solution\nheads_array = np.array(heads_results)\ntails_array = np.array(tails_results)\nheads_avg = np.mean(heads_array)\ntails_avg = np.mean(tails_array)\nheads_sdev = np.std(heads_array)\ntails_sdev = np.std(tails_array)\n#solution\nprint(heads_avg)\nprint(tails_avg)\nprint(heads_sdev)\nprint(tails_sdev)\n0.498\n0.502\n0.1092291169972549\n0.1092291169972549\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\n#solution\nplt.hist(tails_results, color = 'gray',bins = 9)\nplt.axvline(x = tails_avg, color = 'r', label = 'mean result for tails')\nxmin = tails_avg - tails_sdev\nxmax = tails_avg + tails_sdev\nplt.axvspan(xmin,xmax, color='r', alpha=0.25)\nplt.show()\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\n#solution\nheads_err = heads_sdev/np.sqrt(len(heads_array))\ntails_err = tails_sdev/np.sqrt(len(tails_array))\n#solution\nprint(f\"The coin will land on heads {heads_avg*100}% plus or minus {heads_err*100}% of the time\")\nprint(f\"The coin will land on tails {tails_avg*100}% plus or minus {tails_err*100}% of the time\")\nThe coin will land on heads 49.8% plus or minus 0.3454127965203374% of the time\nThe coin will land on tails 50.2% plus or minus 0.3454127965203374% of the time\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n#solution\nplt.plot(np.cumsum(tails_results)/np.arange(1,len(tails_results)+1,1), color = \"gray\")\nplt.hlines(tails_avg,xmin = 0,xmax =len(tails_results),color = \"r\")\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nLet’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n#solution\nresults_stay = []\nresults_change = []\nfor n in range(10):\n    MontyHall(doors, results_stay, results_change)\n    print(results_stay)\n['goat']\n['goat', 'car']\n['goat', 'car', 'car']\n['goat', 'car', 'car', 'car']\n['goat', 'car', 'car', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat', 'goat']\nresults_stay\nresults_change\n['car', 'goat', 'goat', 'goat', 'car', 'car', 'goat', 'car', 'car', 'car']\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use a modified version of the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks whether won by staying with your original door for “stay” or by changing to the other door for “change” for each experiment.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n#solution\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(1)\n        results_change.append(0)\n    else:\n        results_stay.append(0)\n        results_change.append(1)\n        \ndef MontyHallMC(n_MC):\n    results_stay = [] \n    results_change = []\n    for n in range(n_MC):\n        MontyHall(doors, results_stay, results_change)\n    results = {}\n    results[\"stay\"] = np.asarray(results_stay)\n    results[\"change\"] = np.asarray(results_change)\n    return results\n#solution\nresults_10 = MontyHallMC(10)\nplt.plot(np.cumsum(results_10[\"stay\"])/np.arange(1,len(results_10[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_10[\"change\"])/np.arange(1,len(results_10[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_100 = MontyHallMC(100)\nplt.plot(np.cumsum(results_100[\"stay\"])/np.arange(1,len(results_100[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_100[\"change\"])/np.arange(1,len(results_100[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_1000 = MontyHallMC(1000)\nplt.plot(np.cumsum(results_1000[\"stay\"])/np.arange(1,len(results_1000[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_1000[\"change\"])/np.arange(1,len(results_1000[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nLest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\n#solution\ndef roll():\n    r = rd.randrange(1,101)\n    if r &gt; 51:\n        return True\n    else:\n        return False\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\n#solution\ndef play_game(starting_funds,wager,num_plays):\n    outcomes = np.array([starting_funds])\n    funds = starting_funds\n    for n in range(num_plays):\n        if roll():\n            funds += wager\n        else:\n            funds -= wager\n        outcomes = np.append(outcomes,funds)\n    return outcomes\n#solution\nplay_game(100,10,10)\narray([100, 110, 100,  90, 100, 110, 100,  90,  80,  70,  80])\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n#solution\ndef MC_gambling(n_MC, starting_funds, wager, num_plays):\n    MC_outcomes = []\n    for n in range(n_MC):\n        outcomes = play_game(starting_funds,wager,num_plays)\n        plt.plot(outcomes, alpha = 0.25)\n        MC_outcomes.append(outcomes)\n    plays = np.arange(0,num_plays+1,1)\n    MC_avg = np.mean(MC_outcomes,axis = 0)\n    MC_err = np.std(MC_outcomes,axis = 0)/np.sqrt(n_MC)\n    plt.errorbar(x = plays, y = MC_avg, yerr = MC_err, color = \"black\")#, linestyle = \"dashed\")\n    plt.show()\n    plt.errorbar(x = plays, y= MC_avg, yerr = MC_err, color = \"black\")\n    plt.show()\n#solution\nn_MC = 1000\nstarting_funds = 100\nwager = 10\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?\n\n#solution\n#scenario 1\nstarting_funds = 10000\nwager = 100\nnum_plays = 5\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 2\nstarting_funds = 10000\nwager = 100\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 3\nstarting_funds = 1000\nwager = 100\nnum_plays = 100\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 4\nstarting_funds = 10000\nwager = 100\nnum_plays = 10000\nMC_gambling(n_MC, starting_funds, wager, num_plays)"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#a-simple-scenario-flipping-a-coin",
    "href": "SDS271/F23/Lab2_solutions.html#a-simple-scenario-flipping-a-coin",
    "title": "SDS 271 Lab 2: Statistics and Betting",
    "section": "",
    "text": "What do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n1\n6\n4\n5\n3\n2\n3\n5\n1\n3\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\nheads\nheads\ntails\ntails\ntails\ntails\nheads\nheads\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\ntails\ntails\nheads\ntails\ntails\ntails\nheads\nheads\nheads\ntails\nheads\nheads\nheads\nheads\nheads\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.5, 'tails': 0.5}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.35, 'tails': 0.65}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#monte-carlo-methods",
    "href": "SDS271/F23/Lab2_solutions.html#monte-carlo-methods",
    "title": "SDS 271 Lab 2: Statistics and Betting",
    "section": "",
    "text": "Monte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.5, 'tails': 0.5}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands -- it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\n#solution\nimport numpy as np\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\n#solution\nheads_array = np.array(heads_results)\ntails_array = np.array(tails_results)\nheads_avg = np.mean(heads_array)\ntails_avg = np.mean(tails_array)\nheads_sdev = np.std(heads_array)\ntails_sdev = np.std(tails_array)\n#solution\nprint(heads_avg)\nprint(tails_avg)\nprint(heads_sdev)\nprint(tails_sdev)\n0.498\n0.502\n0.1092291169972549\n0.1092291169972549\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\n#solution\nplt.hist(tails_results, color = 'gray',bins = 9)\nplt.axvline(x = tails_avg, color = 'r', label = 'mean result for tails')\nxmin = tails_avg - tails_sdev\nxmax = tails_avg + tails_sdev\nplt.axvspan(xmin,xmax, color='r', alpha=0.25)\nplt.show()\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\n#solution\nheads_err = heads_sdev/np.sqrt(len(heads_array))\ntails_err = tails_sdev/np.sqrt(len(tails_array))\n#solution\nprint(f\"The coin will land on heads {heads_avg*100}% plus or minus {heads_err*100}% of the time\")\nprint(f\"The coin will land on tails {tails_avg*100}% plus or minus {tails_err*100}% of the time\")\nThe coin will land on heads 49.8% plus or minus 0.3454127965203374% of the time\nThe coin will land on tails 50.2% plus or minus 0.3454127965203374% of the time\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n#solution\nplt.plot(np.cumsum(tails_results)/np.arange(1,len(tails_results)+1,1), color = \"gray\")\nplt.hlines(tails_avg,xmin = 0,xmax =len(tails_results),color = \"r\")\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#the-monty-hall-problem",
    "href": "SDS271/F23/Lab2_solutions.html#the-monty-hall-problem",
    "title": "SDS 271 Lab 2: Statistics and Betting",
    "section": "",
    "text": "Let’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n#solution\nresults_stay = []\nresults_change = []\nfor n in range(10):\n    MontyHall(doors, results_stay, results_change)\n    print(results_stay)\n['goat']\n['goat', 'car']\n['goat', 'car', 'car']\n['goat', 'car', 'car', 'car']\n['goat', 'car', 'car', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat', 'goat']\nresults_stay\nresults_change\n['car', 'goat', 'goat', 'goat', 'car', 'car', 'goat', 'car', 'car', 'car']\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use a modified version of the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks whether won by staying with your original door for “stay” or by changing to the other door for “change” for each experiment.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n#solution\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(1)\n        results_change.append(0)\n    else:\n        results_stay.append(0)\n        results_change.append(1)\n        \ndef MontyHallMC(n_MC):\n    results_stay = [] \n    results_change = []\n    for n in range(n_MC):\n        MontyHall(doors, results_stay, results_change)\n    results = {}\n    results[\"stay\"] = np.asarray(results_stay)\n    results[\"change\"] = np.asarray(results_change)\n    return results\n#solution\nresults_10 = MontyHallMC(10)\nplt.plot(np.cumsum(results_10[\"stay\"])/np.arange(1,len(results_10[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_10[\"change\"])/np.arange(1,len(results_10[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_100 = MontyHallMC(100)\nplt.plot(np.cumsum(results_100[\"stay\"])/np.arange(1,len(results_100[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_100[\"change\"])/np.arange(1,len(results_100[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_1000 = MontyHallMC(1000)\nplt.plot(np.cumsum(results_1000[\"stay\"])/np.arange(1,len(results_1000[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_1000[\"change\"])/np.arange(1,len(results_1000[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#why-the-house-always-wins",
    "href": "SDS271/F23/Lab2_solutions.html#why-the-house-always-wins",
    "title": "SDS 271 Lab 2: Statistics and Betting",
    "section": "",
    "text": "Lest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\n#solution\ndef roll():\n    r = rd.randrange(1,101)\n    if r &gt; 51:\n        return True\n    else:\n        return False\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\n#solution\ndef play_game(starting_funds,wager,num_plays):\n    outcomes = np.array([starting_funds])\n    funds = starting_funds\n    for n in range(num_plays):\n        if roll():\n            funds += wager\n        else:\n            funds -= wager\n        outcomes = np.append(outcomes,funds)\n    return outcomes\n#solution\nplay_game(100,10,10)\narray([100, 110, 100,  90, 100, 110, 100,  90,  80,  70,  80])\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n#solution\ndef MC_gambling(n_MC, starting_funds, wager, num_plays):\n    MC_outcomes = []\n    for n in range(n_MC):\n        outcomes = play_game(starting_funds,wager,num_plays)\n        plt.plot(outcomes, alpha = 0.25)\n        MC_outcomes.append(outcomes)\n    plays = np.arange(0,num_plays+1,1)\n    MC_avg = np.mean(MC_outcomes,axis = 0)\n    MC_err = np.std(MC_outcomes,axis = 0)/np.sqrt(n_MC)\n    plt.errorbar(x = plays, y = MC_avg, yerr = MC_err, color = \"black\")#, linestyle = \"dashed\")\n    plt.show()\n    plt.errorbar(x = plays, y= MC_avg, yerr = MC_err, color = \"black\")\n    plt.show()\n#solution\nn_MC = 1000\nstarting_funds = 100\nwager = 10\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?\n\n#solution\n#scenario 1\nstarting_funds = 10000\nwager = 100\nnum_plays = 5\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 2\nstarting_funds = 10000\nwager = 100\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 3\nstarting_funds = 1000\nwager = 100\nnum_plays = 100\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 4\nstarting_funds = 10000\nwager = 100\nnum_plays = 10000\nMC_gambling(n_MC, starting_funds, wager, num_plays)"
  }
]