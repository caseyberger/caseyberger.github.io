[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Casey E Berger",
    "section": "",
    "text": "Assistant Professor, Physics and Astronomy, Bates College"
  },
  {
    "objectID": "index.html#interdisciplinary-science",
    "href": "index.html#interdisciplinary-science",
    "title": "Casey E Berger",
    "section": "Interdisciplinary Science",
    "text": "Interdisciplinary Science\nLife is more interesting on the boundaries!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResearch and Publications\nData Science for Physicists\n\n\n\n\nI talk all about my love of interdisciplinary science and the false STEM-humanities dichotomy in this Fellow Profile from the 2019 DEIXIS magazine"
  },
  {
    "objectID": "cv_and_pubs.html",
    "href": "cv_and_pubs.html",
    "title": "CV and Publications",
    "section": "",
    "text": "My up-to-date academic CV as of August 2024 can be found here",
    "crumbs": [
      "CV and Publications"
    ]
  },
  {
    "objectID": "inclusive_classroom.html",
    "href": "inclusive_classroom.html",
    "title": "Building an Inclusive Classroom",
    "section": "",
    "text": "How can you be sure students of all backgrounds feel comfortable in your class?",
    "crumbs": [
      "Building an Inclusive Classroom"
    ]
  },
  {
    "objectID": "teaching_philosophy.html",
    "href": "teaching_philosophy.html",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Traditional lecture-heavy lesson planning is not the most effective way to facilitate student learning. My teaching philosophy incorporates research-backed methods to help students build efficacy and cultivate a set of tools they can use beyond my classroom.\nUsing research-backed methods in the classroom takes time and effort. It’s challenging, and there are lots of barriers to implementation. But it’s worth it.\n\n\nLearning is an active process. If I stand in front of the classroom and deliver a perfect lecture, the best case is that students will absorb the information I’ve provided and be able to regurgitate it later on an exam. But this style of teaching gives the students no opportunities to practice applying that information. Active learning improves retention of knowledge, and it facilitates the acquisition of a deeper understanding: not just a memorization of facts, but an ability to apply the knowledge in more complex ways.\nActive learning is effective not only at the introductory level, but also in advanced graduate coursework.\n\n\n\nStudents benefit greatly from working with their peers. Those who may need a little extra support are able to watch their peers model their thinking process and are likely to share the same questions, which reinforces a growth mindset. Students who are already on top of the material benefit as well, as walking a peer through how they arrived at the answer strengthens their own understanding of the concept and can help reveal nuance. Groups should be kept small enough that all students are able to contribute, but large enough to balance out possible power dynamics. The most successful groups have been shown to be around 3-5 students.\nBut the community is not just between students and their peers: it includes the instructor as well. My practice is to trust my students and to work with them on an individual level. We are all still learning how to learn (even those of us who have been doing this a long time), and taking ownership of your own education is far more valuable than performing well in a classroom with rigid expectations. The trust between student and instructor takes time to develop, but it’s essential to supporting students in a way that prepares them for the world outside the classroom.\n\n\n\nShort-term memory is extremely limited. The human brain is built to process information, but it can only handle so much at one time. Every embellishment – from complicated visuals to interesting side stories – steals attention away from the concepts being presented and minimizing the ability of students to absorb the information.\n\n\n\nJargon is a useful shorthand. But in order for the shorthand to be effective, the people using the jargon need to understand the underlying concepts.\nJargon is for experts, not learners. Introducing shorthand words – even if they are standard in the field – only obfuscates the concepts.\n\n\n\nIf students feel unsafe or like they don’t belong, their ability to learn and grow will be limited.\nThere are many things you can do to make your classroom safer and more inclusive.",
    "crumbs": [
      "Teaching Philosophy"
    ]
  },
  {
    "objectID": "teaching_philosophy.html#active-learning",
    "href": "teaching_philosophy.html#active-learning",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Learning is an active process. If I stand in front of the classroom and deliver a perfect lecture, the best case is that students will absorb the information I’ve provided and be able to regurgitate it later on an exam. But this style of teaching gives the students no opportunities to practice applying that information. Active learning improves retention of knowledge, and it facilitates the acquisition of a deeper understanding: not just a memorization of facts, but an ability to apply the knowledge in more complex ways.\nActive learning is effective not only at the introductory level, but also in advanced graduate coursework.",
    "crumbs": [
      "Teaching Philosophy"
    ]
  },
  {
    "objectID": "teaching_philosophy.html#building-community",
    "href": "teaching_philosophy.html#building-community",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Students benefit greatly from working with their peers. Those who may need a little extra support are able to watch their peers model their thinking process and are likely to share the same questions, which reinforces a growth mindset. Students who are already on top of the material benefit as well, as walking a peer through how they arrived at the answer strengthens their own understanding of the concept and can help reveal nuance. Groups should be kept small enough that all students are able to contribute, but large enough to balance out possible power dynamics. The most successful groups have been shown to be around 3-5 students.\nBut the community is not just between students and their peers: it includes the instructor as well. My practice is to trust my students and to work with them on an individual level. We are all still learning how to learn (even those of us who have been doing this a long time), and taking ownership of your own education is far more valuable than performing well in a classroom with rigid expectations. The trust between student and instructor takes time to develop, but it’s essential to supporting students in a way that prepares them for the world outside the classroom.",
    "crumbs": [
      "Teaching Philosophy"
    ]
  },
  {
    "objectID": "teaching_philosophy.html#reducing-distractions",
    "href": "teaching_philosophy.html#reducing-distractions",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Short-term memory is extremely limited. The human brain is built to process information, but it can only handle so much at one time. Every embellishment – from complicated visuals to interesting side stories – steals attention away from the concepts being presented and minimizing the ability of students to absorb the information.",
    "crumbs": [
      "Teaching Philosophy"
    ]
  },
  {
    "objectID": "teaching_philosophy.html#concepts-first-jargon-later",
    "href": "teaching_philosophy.html#concepts-first-jargon-later",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "Jargon is a useful shorthand. But in order for the shorthand to be effective, the people using the jargon need to understand the underlying concepts.\nJargon is for experts, not learners. Introducing shorthand words – even if they are standard in the field – only obfuscates the concepts.",
    "crumbs": [
      "Teaching Philosophy"
    ]
  },
  {
    "objectID": "teaching_philosophy.html#safe-and-inclusive-classrooms",
    "href": "teaching_philosophy.html#safe-and-inclusive-classrooms",
    "title": "Teaching Philosophy",
    "section": "",
    "text": "If students feel unsafe or like they don’t belong, their ability to learn and grow will be limited.\nThere are many things you can do to make your classroom safer and more inclusive.",
    "crumbs": [
      "Teaching Philosophy"
    ]
  },
  {
    "objectID": "bio.html",
    "href": "bio.html",
    "title": "About Me",
    "section": "",
    "text": "Academic Bio\nI am an assistant professor of physics at Bates College. I have previously held positions as an assistant professor of physics and data science at Smith College and a postdoctoral research associate at Boston University in the physics department and the Hariri Institute for Computing. I earned my PhD from the University of North Carolina at Chapel Hill, where I was a Department of Energy Computational Science Graduate Fellow and a William Neal Reynolds fellow in the Royster Society of Fellows. My research is in computational and data science methods in many-body quantum mechanics.\nI also work on issues of diversity and equity in STEM, with an emphasis on improving representation and support of women, LGBTQ folks, BIPOC, and other underrepresented groups in STEM. When I’m not working in STEM and STEM-related pursuits, you can find me running, cooking, practicing photography, or writing.\n\n\nAbout my books\nIf you’re interested in learning more about my published works of fiction, you can do that at my author website.",
    "crumbs": [
      "About Me"
    ]
  },
  {
    "objectID": "python_data_science.html",
    "href": "python_data_science.html",
    "title": "Teaching Data Science to Physics Students",
    "section": "",
    "text": "So you want to teach your physics students some data science?\nFortunately, there are lots of resources to help you do just this! I’ve put together a handy guide that should help walk you through this process, whether you’re just hearing the words “Python programming language” for the first time or a seasoned pro.\nIf you are completely new to Python, you should start with The Basics of Python, where I walk through a basic Python bootcamp and provide links to other resources for practice.\n\nGetting StartedReady to Dive InDig Deeper\n\n\nIn this section are a number of resources to help walk you through some of the most widely-used (and accessible) tools for programming in the classroom. There, you can learn some basic Python, get comfortable with a free and easy to use (no downloads or installs required!) coding environment, and get some best practices tips for teaching students who are also just getting started.\nIf you don’t already have Python installed on your machine, or if you don’t already have access to a cloud-based programming environment (like JupyterHub or Posit), this notebook will walk you through Google Colab, which is an excellent, free option if you want to program with Python and don’t want to have to install a bunch of programs on your computer. All you need to start this process is a Google account.\nThis tutorial will walk you through the basics of Colab. Click on this link, and it should take you to a page that looks like this:\n\n\nIn this section, you can find modules developed by graduate and postdoctoral fellows in the Data Science Education Community of Practice (DSECOP), part of the American Physical Society’s topical Group on Data Science. These modules are designed to fit into physics courses and can be adapted for students at varying levels of coding ability\n\n\nIn this section, you will find more modules by the DSECOP fellows, which are intended for more advanced students. Once students have gained some familiarity with data science tools and processes (using the earlier modules, for example), they will be ready for these modules.",
    "crumbs": [
      "Teaching Data Science to Physics Students"
    ]
  },
  {
    "objectID": "python_data_science.html#python-basics",
    "href": "python_data_science.html#python-basics",
    "title": "Teaching Python and Data Science to Physics Students",
    "section": "Python basics",
    "text": "Python basics"
  },
  {
    "objectID": "python_data_science.html#using-google-colab",
    "href": "python_data_science.html#using-google-colab",
    "title": "Teaching Python and Data Science to Physics Students",
    "section": "Using Google colab",
    "text": "Using Google colab\nIf you don’t already have Python installed on your machine, or if you don’t already have access to a cloud-based programming environment (like JupyterHub or Posit), this notebook will walk you through Google Colab, which is an excellent, free option if you want to program with Python and don’t want to have to install a bunch of programs on your computer. All you need to start this process is a Google account.\nThis tutorial will walk you through the basics of Colab. Click on this link, and it should take you to a page that looks like this:"
  },
  {
    "objectID": "beginning_python.html",
    "href": "beginning_python.html",
    "title": "Beginning Python",
    "section": "",
    "text": "If you’re brand new to Python, this page will walk you through everything from installation to basic Python syntax. You can also find a list of Additional References for more detail and opportunities to practice.\n\nShould I install Python or use a cloud-based environment?\nThis depends on your own needs. If you want to be able to work offline, then you’ll want to install Python on your local machine. But if you can reliably expect access to the internet, then an online service will be a lot quicker to start with and will prevent the need to manage updates, install special packages, or deal with software incompatibilities.\nIn both cases, I recommend working with Jupyter notebooks to begin. A Jupyter notebook allows you to run code in small chunks as well as leave clear notes and documentation throughout. If you have worked with Posit or RStudio, you will already be familiar with how this works. If you haven’t, don’t worry! We will walk through it below.\n\nInstalling Python and JupyterLabAccessing Google Colab\n\n\n\n\n\n\n\n\n\n\n\nUsing a Notebook (Jupyter or Colab)\n\n\nAdditional References\nPython’s guide to Python for Beginners",
    "crumbs": [
      "Beginning Python"
    ]
  },
  {
    "objectID": "beginning_python.html#should-i-install-python-or-use-a-cloud-based-environment",
    "href": "beginning_python.html#should-i-install-python-or-use-a-cloud-based-environment",
    "title": "Beginning Python",
    "section": "Should I install Python or use a cloud-based environment?",
    "text": "Should I install Python or use a cloud-based environment?\nThis depends on your own needs. If you want to be able to work offline, then you’ll want to install Python on your local machine. But if you can reliably expect access to the internet, then an online service will be a lot quicker to start with and will prevent the need to manage updates, install special packages, or deal with software incompatibilities.\nIn both cases, I recommend working with Jupyter notebooks to begin. A Jupyter notebook allows you to run code in small chunks as well as leave clear notes and documentation throughout. If you have worked with Posit or RStudio, you will already be familiar with how this works. If you haven’t, don’t worry! We will walk through it below.\n\nInstalling Python and JupyterLabAccessing Google Colab"
  },
  {
    "objectID": "beginning_python.html#additional-references",
    "href": "beginning_python.html#additional-references",
    "title": "Beginning Python",
    "section": "Additional References",
    "text": "Additional References\nPython’s guide to Python for Beginners"
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html",
    "href": "SDS271/F23/Lab1_clean.html",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "This introductory lab will serve as a refresher on the Python skills you learned in previous classes, as well as a chance to get to know the course structure and content.\nYou can download the .ipynb for this lab here, or you can find it in Moodle.\n\n\nFor the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!\n\n\n\n\n\nIf you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report here\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes.\n\n\n\n\n\nOne of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function.\n\n\n\n\n\nPython can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words.\n\n\n\n\nAnother way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this.\n\n\n\n\nA central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list[\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth"
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#a-note-on-the-labs",
    "href": "SDS271/F23/Lab1_clean.html#a-note-on-the-labs",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "For the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!"
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#part-one-jupyterhub",
    "href": "SDS271/F23/Lab1_clean.html#part-one-jupyterhub",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "If you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report here\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#part-two-python-refresher-and-syllabus-activity",
    "href": "SDS271/F23/Lab1_clean.html#part-two-python-refresher-and-syllabus-activity",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "One of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#lists",
    "href": "SDS271/F23/Lab1_clean.html#lists",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "Python can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#dictionaries",
    "href": "SDS271/F23/Lab1_clean.html#dictionaries",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "Another way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this."
  },
  {
    "objectID": "SDS271/F23/Lab1_clean.html#loops-and-functions",
    "href": "SDS271/F23/Lab1_clean.html#loops-and-functions",
    "title": "Lab 1: Getting Started",
    "section": "",
    "text": "A central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list[\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth"
  },
  {
    "objectID": "SDS271/F23/sds-271-f23-homepage.html",
    "href": "SDS271/F23/sds-271-f23-homepage.html",
    "title": "SDS 271 Fall 2023",
    "section": "",
    "text": "Welcome to the Fall 2023 version of SDS 271: Advanced Programming for Data Science in Python!"
  },
  {
    "objectID": "sds-271-f23-homepage.html",
    "href": "sds-271-f23-homepage.html",
    "title": "SDS 271 Fall 2023",
    "section": "",
    "text": "Welcome to the Fall 2023 version of SDS 271: Advanced Programming for Data Science in Python!"
  },
  {
    "objectID": "sds-271-f23-homepage.html#syllabus-and-schedule",
    "href": "sds-271-f23-homepage.html#syllabus-and-schedule",
    "title": "SDS 271 Fall 2023",
    "section": "Syllabus and Schedule",
    "text": "Syllabus and Schedule\nThe course syllabus can be found here.\n\nThe course schedule can be found here. It will be updated regularly and is subject to change."
  },
  {
    "objectID": "sds-271-f23-homepage.html#accessing-compute-resources-and-reporting-issues",
    "href": "sds-271-f23-homepage.html#accessing-compute-resources-and-reporting-issues",
    "title": "SDS 271 Fall 2023",
    "section": "Accessing Compute Resources and Reporting Issues",
    "text": "Accessing Compute Resources and Reporting Issues\nYou can access the Smith JupyterHub server here. You will need to log in with your Smith credentials. If you are off-campus, you will have to log into a VPN to get access.\n\nInstructions on how to install the Pulse Secure VPN can be found [on the Smith website] (https://www.smith.edu/its/tara/networking/vpn.html). You need to log in to the VPN with your Smith credentials before accessing JupyterHub. Once you’ve signed in (and done the Duo push), you should be able to access the server as normal.\n\nIf you have a bug or connection issue to report, you can do so here."
  },
  {
    "objectID": "sds-271-f23-homepage.html#providing-feedback",
    "href": "sds-271-f23-homepage.html#providing-feedback",
    "title": "SDS 271 Fall 2023",
    "section": "Providing Feedback",
    "text": "Providing Feedback\nIf you have feedback for me that you are not comfortable sharing directly but would like me to take into acocunt, please don’t hesitate to leave it here. This form is entirely anonymous – the only information I ask for is the class that this is about."
  },
  {
    "objectID": "sds-271-f23-homepage.html#lab-1",
    "href": "sds-271-f23-homepage.html#lab-1",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 1",
    "text": "Lab 1\nLab 1 is all about getting started with JupyterHub and reviewing your previous Python experience.\nYou can find the .ipynb for this lab in Moodle, or at this link if you’d prefer to use Google colab."
  },
  {
    "objectID": "sds-271-f23-homepage.html#textbook",
    "href": "sds-271-f23-homepage.html#textbook",
    "title": "SDS 271 Fall 2023",
    "section": "Textbook",
    "text": "Textbook\nThe textbook is Python for Data Analysis, 3rd edition, and is available for free online."
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html",
    "href": "SDS271/F23/Lab2_clean.html",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "This lab will dig a little more deeply into your previous Python experience as we examine two case studies in statistical simulations: the Monty Hall Problem and why the House always wins in gambling.\n\n\nWhat do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n\n\n\n\nMonte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nLet’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nLest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: \n\nStarting funds:\n\n\nWager amount: 100\n\n\nNumber of bets : 5\n\n\nScenario 2: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10\n\n\nScenario 3: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 100\n\n\nScenario 4: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10000\n\n\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#a-simple-scenario-flipping-a-coin",
    "href": "SDS271/F23/Lab2_clean.html#a-simple-scenario-flipping-a-coin",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "What do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#monte-carlo-methods",
    "href": "SDS271/F23/Lab2_clean.html#monte-carlo-methods",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "Monte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#the-monty-hall-problem",
    "href": "SDS271/F23/Lab2_clean.html#the-monty-hall-problem",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "Let’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#why-the-house-always-wins",
    "href": "SDS271/F23/Lab2_clean.html#why-the-house-always-wins",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "Lest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)"
  },
  {
    "objectID": "SDS271/F23/Lab2_clean.html#the-simulation",
    "href": "SDS271/F23/Lab2_clean.html#the-simulation",
    "title": "Lab 2: Statistics and Betting",
    "section": "",
    "text": "We need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: \n\nStarting funds:\n\n\nWager amount: 100\n\n\nNumber of bets : 5\n\n\nScenario 2: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10\n\n\nScenario 3: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 100\n\n\nScenario 4: \n\nStarting funds: 10000\n\n\nWager amount: 100\n\n\nNumber of bets : 10000\n\n\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "sds-271-f23-homepage.html#lab-2",
    "href": "sds-271-f23-homepage.html#lab-2",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 2",
    "text": "Lab 2\nLab 2 gives you a chance to dig deeper into Python; learn how to import and use Python packages like random, matplotlib, and numpy; and apply your previous statistical knowledge to explore the dangers of making uninformed wagers."
  },
  {
    "objectID": "sds-271-f23-homepage.html#office-hours",
    "href": "sds-271-f23-homepage.html#office-hours",
    "title": "SDS 271 Fall 2023",
    "section": "Office Hours",
    "text": "Office Hours\nMondays 10AM-11AM and Tuesdays 1PM-2PM, McConnell 214\n\nOr by appointment: www.calendly.com/caseyberger"
  },
  {
    "objectID": "sds-271-f23.html",
    "href": "sds-271-f23.html",
    "title": "SDS 271 Fall 2023",
    "section": "",
    "text": "Welcome to the Fall 2023 version of SDS 271: Programming for Data Science in Python!"
  },
  {
    "objectID": "sds-271-f23.html#textbook",
    "href": "sds-271-f23.html#textbook",
    "title": "SDS 271 Fall 2023",
    "section": "Textbook",
    "text": "Textbook\nThe textbook is Python for Data Analysis, 3rd edition, and is available for free online."
  },
  {
    "objectID": "sds-271-f23.html#syllabus-and-schedule",
    "href": "sds-271-f23.html#syllabus-and-schedule",
    "title": "SDS 271 Fall 2023",
    "section": "Syllabus and Schedule",
    "text": "Syllabus and Schedule\nThe course syllabus can be found here.\n\nThe course schedule can be found here. It will be updated regularly and is subject to change."
  },
  {
    "objectID": "sds-271-f23.html#office-hours",
    "href": "sds-271-f23.html#office-hours",
    "title": "SDS 271 Fall 2023",
    "section": "Office Hours",
    "text": "Office Hours\n\nCasey\nMondays 10AM-11AM and Tuesdays 1PM-2PM, McConnell 214\n\nOr by appointment (link in Moodle)\n\n\nAlina\nTuesdays 8:30AM-10:30AM over zoom (message her on Slack!)\n\n\nClara\nWednesdays 6PM-7PM\nby appointment via zoom (times vary; reach out via Slack if no available times work for you)"
  },
  {
    "objectID": "sds-271-f23.html#accessing-compute-resources-and-reporting-issues",
    "href": "sds-271-f23.html#accessing-compute-resources-and-reporting-issues",
    "title": "SDS 271 Fall 2023",
    "section": "Accessing Compute Resources and Reporting Issues",
    "text": "Accessing Compute Resources and Reporting Issues\nYou can access the Smith JupyterHub server here. You will need to log in with your Smith credentials. If you are off-campus, you will have to log into a VPN to get access.\n\nInstructions on how to install the Pulse Secure VPN can be found [on the Smith website] (https://www.smith.edu/its/tara/networking/vpn.html). You need to log in to the VPN with your Smith credentials before accessing JupyterHub. Once you’ve signed in (and done the Duo push), you should be able to access the server as normal.\n\nIf you have a bug or connection issue to report, you can do so here."
  },
  {
    "objectID": "sds-271-f23.html#providing-feedback",
    "href": "sds-271-f23.html#providing-feedback",
    "title": "SDS 271 Fall 2023",
    "section": "Providing Feedback",
    "text": "Providing Feedback\nIf you have feedback for me that you are not comfortable sharing directly but would like me to take into acocunt, please don’t hesitate to leave it here. This form is entirely anonymous – the only information I ask for is the class that this is about."
  },
  {
    "objectID": "sds-271-f23.html#lab-1",
    "href": "sds-271-f23.html#lab-1",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 1",
    "text": "Lab 1\nLab 1 is all about getting started with JupyterHub and reviewing your previous Python experience.\nYou can find the .ipynb for this lab in Moodle, or at this link.\nLab 1 solutions"
  },
  {
    "objectID": "sds-271-f23.html#lab-2",
    "href": "sds-271-f23.html#lab-2",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 2",
    "text": "Lab 2\nLab 2 gives you a chance to dig deeper into Python; learn how to import and use Python packages like random, matplotlib, and numpy; and apply your previous statistical knowledge to explore the dangers of making uninformed wagers.\nLab 2 Solutions"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html",
    "href": "SDS271/F23/Lab2_solutions_09_12.html",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "This lab will dig a little more deeply into your previous Python experience as we examine two case studies in statistical simulations: the Monty Hall Problem and why the House always wins in gambling.\n\n\nWhat do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n&lt;li&gt; Pick randomly from a list of \"heads\" and \"tails\" &lt;/li&gt;\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n5\n4\n3\n1\n5\n3\n1\n4\n2\n3\nfor n in range(10):\n    print(rd.randint(1,6))\n3\n1\n1\n6\n6\n3\n3\n4\n2\n5\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\ntails\nheads\nheads\ntails\nheads\ntails\nheads\ntails\ncoin_list[0]\n'heads'\nfor n in range(10):\n    r = rd.randint(0,1)\n    print(coin_list[r])\nheads\nheads\ntails\ntails\nheads\ntails\ntails\ntails\ntails\ntails\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\nheads\ntails\nheads\ntails\ntails\nheads\nheads\nheads\ntails\ntails\nheads\nheads\ntails\ntails\ntails\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.3, 'tails': 0.7}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n\nStop here for a minute. Check-in with sli.do and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nMonte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.85, 'tails': 0.15}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nLet’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nLest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#a-simple-scenario-flipping-a-coin",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#a-simple-scenario-flipping-a-coin",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "What do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n&lt;li&gt; Pick randomly from a list of \"heads\" and \"tails\" &lt;/li&gt;\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n5\n4\n3\n1\n5\n3\n1\n4\n2\n3\nfor n in range(10):\n    print(rd.randint(1,6))\n3\n1\n1\n6\n6\n3\n3\n4\n2\n5\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\ntails\nheads\nheads\ntails\nheads\ntails\nheads\ntails\ncoin_list[0]\n'heads'\nfor n in range(10):\n    r = rd.randint(0,1)\n    print(coin_list[r])\nheads\nheads\ntails\ntails\nheads\ntails\ntails\ntails\ntails\ntails\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\nheads\ntails\nheads\ntails\ntails\nheads\nheads\nheads\ntails\ntails\nheads\nheads\ntails\ntails\ntails\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.3, 'tails': 0.7}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.55, 'tails': 0.45}\n\nStop here for a minute. Check-in with sli.do and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#monte-carlo-methods",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#monte-carlo-methods",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Monte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.85, 'tails': 0.15}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands – it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#the-monty-hall-problem",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#the-monty-hall-problem",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Let’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks how many times you have won by staying with your original door for “stay” or by changing to the other door for “change”.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#why-the-house-always-wins",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#why-the-house-always-wins",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Lest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions_09_12.html#the-simulation",
    "href": "SDS271/F23/Lab2_solutions_09_12.html#the-simulation",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "We need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html",
    "href": "SDS271/F23/Lab1_solutions.html",
    "title": "Lab 1 solutions: Welcome to SDS 271!",
    "section": "",
    "text": "This introductory lab will serve as a refresher on the Python skills you learned in previous classes, as well as a chance to get to know the course structure and content.\n\n\nFor the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!\n\n\n\n\n\nIf you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report &lt;a href=\"https://forms.gle/FfBe5VvMCgqHy5Vi6\"&gt;here&lt;/a&gt;.\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n# solution\n1 + 1\n2\n//solution\nI used a cell to evaluate 1 + 1 and got the output 2, as expected.\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n#solution\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\n    x += 1\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes.\n\n\n\n\n\nOne of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\n# solution\ncourse_num = 271\ninstructor = \"Casey\"\ninst_email = \"cberger@smith.edu\"\nclass_len_hours = 1.25\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n#solution\nprint(type(course_num))\nprint(type(instructor))\nprint(type(inst_email))\nprint(type(class_len_hours))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'str'&gt;\n&lt;class 'float'&gt;\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function.\n\n\n\n\n\nPython can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words.\n\n#solution\ncourse_objectives = [\"write your own functions and packages in Python\",\n                    \"utilize class structures in Python to create reproducible, organized processes for data manupulation\",\n                    \"understand when to use functions and when to use classes\", \"submit a pull request to GitHub\",\n                    \"create clear and helpful documentation for your code\", \n                     \"use the Pandas library to organize, manage, and manipulate data\",\n                    \"explore a dataset visually with seaborn\",\n                    \"tell a story with data through effective visualizations\",\n                     \"write a complete Python package\"]\n\n\n\nAnother way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\n# solution\ngrades = {\"Labs\":0.2,\"Project 1\": 0.1, \"Project 2\": 0.15, \"Pull request\":0.05, \"Final Project\": 0.5 }\ngrades[\"Project 2\"]\n0.15\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this.\n\n#solution\ngrades_detailed = {\n    \"Labs\":{\n        \"due\": \"Wednesdays\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"S/U\"\n    },\n    \"Project 1\":{\n        \"due\": \"9/19\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    }, \n    \"Project 2\": {\n        \"due\": \"11/7\",\n        \"grade fraction\":0.15,\n        \"grade type\": \"S/U\"\n    }, \n    \"Pull request\":{\n        \"due\": \"10/31\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    }, \n    \"Final Project Pitch\": {\n        \"due\": \"10/5\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project proposal\":{\n        \"due\": \"10/19\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project rough draft\":{\n        \"due\": \"11/16\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project final draft\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"numerical\"\n    },\n    \"Final project assessments\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"numerical\"\n    }\n}\ngrades_detailed[\"Final project assessments\"]['grade fraction']\n0.1\n\n\n\nA central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list = [\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n# solution\nfor objective in course_objectives:\n    print(objective)\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n# solution\nnum_objectives = len(course_objectives)\ncount = 0\nwhile count &lt; num_objectives:\n    print(course_objectives[count])\n    count +=1\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth\n\n\n\n#solution\ndef what_percent(component, grade_dict):\n    grade_percent = (grade_dict[component]['grade fraction'])\n    return grade_percent\n#solution\nfp_grade = what_percent(\"Final project final draft\",grades_detailed)\nfp_grade\n0.2\n#solution\ndef when_is_this_due(component, grade_dict):\n    due_date = grade_dict[component]['due']\n    print(component+\" is due on \"+due_date)\n#solution\nwhen_is_this_due(\"Final project final draft\",grades_detailed)\nFinal project final draft is due on 12/14"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#a-note-on-the-labs",
    "href": "SDS271/F23/Lab1_solutions.html#a-note-on-the-labs",
    "title": "Lab 1 solutions: Welcome to SDS 271!",
    "section": "",
    "text": "For the first half of the semester, we will focus on skill building through in-class labs. You may or may not be able to complete the lab during class time, it is your responsibility to complete the lab and respond to the self-reflection poll (linked at the end of each lab). These will constitute your “weekly homework” and must be turned in by the due date (usually the Wednesday of the following week).\nIn these labs, you will see information and instructions given in a few ways.\nOrdinary markdown: These traditional black-text-white-background sections are useful instructions, background, etc. You should read them to get context for what you will be doing.\n\nThese sections give you specific tips on how to do something that may be new or tricky.\nLook here first if you are stuck!\n\n\nThese sections give you instructions for what you are supposed to do in order to complete the lab. Consider these the “problem statements” to which you are expected to produce a solution.\n\nIf at any point you are confused about what you are supposed to do, please ask!"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#part-one-jupyterhub",
    "href": "SDS271/F23/Lab1_solutions.html#part-one-jupyterhub",
    "title": "Lab 1 solutions: Welcome to SDS 271!",
    "section": "",
    "text": "If you’re reading this notebook in JupyterHub, then great! You’ve done it! If you’re reading this on the course website, then do the following:\nIn your browser, navigate to jupyterhub.smith.edu\nYou should see a page that looks like this:\n\nEveryone who was already registered for the class or who sent Casey an email before yesterday at 5PM stating their intention to add the class have been added to the list of people who have access to this server. You should be able to log in using your Smith credentials.\nusername: your Smith email address, without the @smith.edu password: the password you use to access your Smith email\nIf you have not registered for the class or emailed Casey before yesterday at 5PM, then you are not on that list. Please speak to Casey and she will ask CATS add you, but it may take a day or two before you get access.\n\nIf you are struggling to connect, please speak to Casey or submit a bug report &lt;a href=\"https://forms.gle/FfBe5VvMCgqHy5Vi6\"&gt;here&lt;/a&gt;.\n\n\nOnce you are able to open the Lab 1 notebook (.ipynb extension) in JupyterHub, please check in on  slido. You may proceed once you have done this.\n\n\n\n\nOnce you have access to JupyterHub, let’s get comfortable with using it. Similar to R Markdown (Quarto) that you used in SDS 100, JupyterHub allows you to write code in special code cells and annotate the code in markdown cells.\n\nTo create a new cell, press the “+” button in the menu along the top of the notebook.\nOnce you have a new cell, click on that cell to select it.\nYou can now choose “Code” or “Markdown” from the dropdown menu above.\nTo evaluate a code cell, use shift+enter.\n\n\nExercise 1:\n\n\nPerform a simple calculation with Python (it can be as easy as 1 + 1) in a cell.\n\n\nLeave a sentence or two in a markdown cell about what you did.\n\n\nThen enjoy some wholesome support from Coach Lasso in the form of a gif.\n\n# solution\n1 + 1\n2\n//solution\nI used a cell to evaluate 1 + 1 and got the output 2, as expected.\n\n\n\n\nSometimes, mistakes happen. Sometimes you write a while loop that has no termination condition and will run until the end of time if you let it. Sometimes you just realize after you ran a cell that you typed the wrong thing. Either way, you can always stop Jupyter in the middle of its processes.\n\nIn the menu at the top of the page, select Kernel &gt; Interrupt to stop the Kernel.\nOnce you’re ready to run the code again, you can re-run.\nYou can also restart the whole kernel and run the notebook from the start (this is often a good first debugging method if you’re not sure why something isn’t working). Kernel &gt; Restart Kernel and Run All Cells\n\nNow, let’s try to see how this works. Here’s a line of code:\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\nWhy do you expect this will be a problem if you try to run it? If you don’t know, talk to a neighbor.\n\nExercise 2:\nOnce you understand the problem, copy the code above into a new code cell and start running it.\nWhen it loops forever, you’ll want to interrupt it using Kernel &gt; Interrupt.\nThen fix the code and rerun it so it only prints “hello world” 10 times.\n\n#solution\nx = 0\nwhile x &lt; 10:\n    print(\"hello world!\")\n    x += 1\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\nhello world!\n\nAnother useful tip: click on the tab on the far left of the browser that looks like a square inside of a circle. That tab will show you what tabs you have open and what kernels are running. It’s good practice to shut down any kernels you are not actively using. If you don’t do this, you will overload the server and have a hard time running your notebooks. Periodically check this tab and clean up your processes."
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#part-two-python-refresher-and-syllabus-activity",
    "href": "SDS271/F23/Lab1_solutions.html#part-two-python-refresher-and-syllabus-activity",
    "title": "Lab 1 solutions: Welcome to SDS 271!",
    "section": "",
    "text": "One of the expectations of this class is that you have previous experience with Python. This is one of the reasons CSC 110 is a course prerequisite. It may have been a while since you’ve used Python, so let’s just refresh the skills you’ve already learned.\nIf you’re feeling particularly rusty, please use the second chapter of the course textbook to remind yourself of these basic Python operations.\n\n\nRecall that in Python, we can create variables, which are placeholders to which we assign some value. That value does not have to be numerical – there are many kinds of data types we could use. Python will automatically assign a type to your data when you enter it, but it helps to be able to check that it’s what you expect.\n\nExercise 3:\nLook through the first page of the syllabus and create variables to represent the following information. You may name the variables however you like, following Python’s naming conventions.\n\n\nCourse number (not including the department prefix), integer\n\n\nInstructor first name, string\n\n\nInstructor email, string\n\n\nLength of the class, floating point number\n\n\nDays of the week we meet, list of strings\n\n\nCourse prerequisites, list of strings\n\n\n\n# solution\ncourse_num = 271\ninstructor = \"Casey\"\ninst_email = \"cberger@smith.edu\"\nclass_len_hours = 1.25\nYou can see how Python stores the variable type using the type() function. For example, if I define\nx = 10\nand then use type(), I should see\ntype(x)\n&gt; int\n\nExercise 4:\nNow use the Python type function to see how Python stored the variables you defined above. Do they match what you expect? If not, what do you need to change to make it right?\n\n#solution\nprint(type(course_num))\nprint(type(instructor))\nprint(type(inst_email))\nprint(type(class_len_hours))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'str'&gt;\n&lt;class 'float'&gt;\n\nIf you are only getting one output printed to the console, that’s because Jupyter only default prints the last operation you ask for. In order to force it to print everything, you need to wrap your instructions in the print() function."
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#lists",
    "href": "SDS271/F23/Lab1_solutions.html#lists",
    "title": "Lab 1 solutions: Welcome to SDS 271!",
    "section": "",
    "text": "Python can store collections of information in a number of ways. The simplest way is a list. To make a list in Python, you use square brackets to enclose the list and separate the entries with commas.\n\nPython can make a list that contains multiple data types! This flexibility is useful but can be quite dangerous, especially when you try to automate things. Although we will be moving away from lists quickly, it’s important to know about this, and in general in this class, we will create “lists” that do not mix data types within one list or list-like object (more on that when we get to Pandas).\n\n\nExercise 5:\nTurn to page two of the syllabus and make a list of the learning objectives you will have completed by the end of the course. You may copy from the syllabus or you may write them in your own words.\n\n#solution\ncourse_objectives = [\"write your own functions and packages in Python\",\n                    \"utilize class structures in Python to create reproducible, organized processes for data manupulation\",\n                    \"understand when to use functions and when to use classes\", \"submit a pull request to GitHub\",\n                    \"create clear and helpful documentation for your code\", \n                     \"use the Pandas library to organize, manage, and manipulate data\",\n                    \"explore a dataset visually with seaborn\",\n                    \"tell a story with data through effective visualizations\",\n                     \"write a complete Python package\"]"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#dictionaries",
    "href": "SDS271/F23/Lab1_solutions.html#dictionaries",
    "title": "Lab 1 solutions: Welcome to SDS 271!",
    "section": "",
    "text": "Another way of organizing information in Python is to create a dictionary. Dictionaries store informaiton using keys and values – you can use the key to find the value you are looking for.\nFor example, if I wanted to make a dictionary for my family’s pets and who they belong to, I could do the following:\npets = {\"Aspen\": \"Casey\", \"Sox\":\"Alannah\", \"Autumn\": \"Michael\"}\nIn this case, the pet names (Aspen, Sox, and Autumn) are the keys, and their person is the value. If I typed in\npets[\"Sox\"]\nI would get the answer “Alannah”.\nYou can use any data type in here, and you can mix data types as well. There is a lot of flexiblity in creating dictionaries.\n\nExercise 6:\nLook at page 3 of the syllabus and create a dictionary for the course compenents and their grading, where the key is the assignment name and the value is the percentage of the grade (express this as a decimal, where 1. = 100%).\n\n# solution\ngrades = {\"Labs\":0.2,\"Project 1\": 0.1, \"Project 2\": 0.15, \"Pull request\":0.05, \"Final Project\": 0.5 }\ngrades[\"Project 2\"]\n0.15\nYou can also make a nested dictionary and add more information. Let’s do this with the pets example first. If I wanted to add more information, like what kind of animal each pet was and how old they are, I can do this by making a key for each pet and then a dictionary as the value. That inner dictionary could then be the information I desired.\nFor example\npets_detailed = {\n    \"Aspen\": {\n        \"person\": \"Casey\",\n        \"age\": 7,\n        \"kind\": \"dog\"\n        },\n    \"Sox\": {\n        \"person\":\"Alannah\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n        },\n   \"Autumn\": {\n       \"person\":\"Michael\",\n        \"age\": 9,\n        \"kind\": \"cat\"\n       }\n    }\nIn this case, the pet names are still the key, but if I choose that key, I get a whole dictionary. I can then select the keys from inside that dictionary. If I want to know whether Sox is a cat or a dog, I can do:\npets_detailed[\"Sox\"][\"kind\"]\nI would get the answer “cat”.\nIf I want to know who is Aspen’s person, I would say:\npets_detailed[\"Aspen\"][\"person\"]\nTo find the keys of a dictionary, you just use the dictionary name and .keys():\npets_detailed.keys()\nreturns\n['Aspen', 'Sox', 'Autumn']\nand\npets_detailed[\"Aspen\"].keys()\nreturns\n['person', 'age', 'kind']\n\nExercise 7:\nMake a new, nested dictionary, where the key is the assignment, and inside you have a dictionary that gives the due date, the percentage of the grade, and whether it’s graded S/U or on a numerical system. Note that you will need divide the final project into its components to do this.\n\n#solution\ngrades_detailed = {\n    \"Labs\":{\n        \"due\": \"Wednesdays\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"S/U\"\n    },\n    \"Project 1\":{\n        \"due\": \"9/19\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    }, \n    \"Project 2\": {\n        \"due\": \"11/7\",\n        \"grade fraction\":0.15,\n        \"grade type\": \"S/U\"\n    }, \n    \"Pull request\":{\n        \"due\": \"10/31\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    }, \n    \"Final Project Pitch\": {\n        \"due\": \"10/5\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project proposal\":{\n        \"due\": \"10/19\",\n        \"grade fraction\":0.05,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project rough draft\":{\n        \"due\": \"11/16\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"S/U\"\n    },\n    \"Final project final draft\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.2,\n        \"grade type\": \"numerical\"\n    },\n    \"Final project assessments\":{\n        \"due\": \"12/14\",\n        \"grade fraction\":0.1,\n        \"grade type\": \"numerical\"\n    }\n}\ngrades_detailed[\"Final project assessments\"]['grade fraction']\n0.1"
  },
  {
    "objectID": "SDS271/F23/Lab1_solutions.html#loops-and-functions",
    "href": "SDS271/F23/Lab1_solutions.html#loops-and-functions",
    "title": "Lab 1 solutions: Welcome to SDS 271!",
    "section": "",
    "text": "A central feature in programming is using the computer to do tedious and repetitive processes. We often do this by using loops – we will look at two kinds of loops in this lab: for loops and while loops.\n\n\nFor loops are given a set number of iterations up front. You can give the loop an existing list or array and ask it to loop over every element inside that list,\nbook_list = [\"The Fifth Season\", \"A Wizard of Earthsea\", \"Jade City\", \"The Light Brigade\"]\nfor book in book_list:\n    print(book)\n\n&gt; \"The Fifth Season\"\n&gt; \"A Wizard of Earthsea\"\n&gt; \"Jade City\"\n&gt; \"The Light Brigade\"\nYou can do something similar with dictionaries:\nfor pet in pets_detailed:\n    print(pet+\" is \"+str(pets_detailed[pet]['age'])+\" years old\")\n\n&gt; Aspen is 7 years old\n&gt; Sox is 9 years old\n&gt; Autumn is 9 years old\nor you can just give it a numerical range in a number of ways:\nx_sum = 0\nfor x in range(0,10):\n    x_sum += x\nx_sum\n\n&gt; 45\nor\nx_sum = 0\nfor x in range(0,10,2):\n    x_sum += x\nx_sum\n\n&gt; 20\n\nIf you don’t understand what that last loop did, be sure to review your Python.\n\n\n\n\nWhile loops don’t have a built in range, so you have to be careful how you write them. You have to construct an end condition and then make sure that condition is reached.\nx_sum = 0\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis won’t even run because the condition (x &gt; 0) immediately evaluates to false, and the loop only runs while that condition is true. However:\nx_sum = 1\nwhile x_sum &gt; 0:\n    x_sum += 1\nThis will run forever, because the condition will always be true.\nx_sum = 0\nwhile x_sum &lt; 10:\n    x_sum += 1\nThis will only run until x_sum reaches the value 10, and then it will stop.\n\nExercise 8:\nUse the list you made earlier of the course objectives, and write a program that loops over that list and prints each learning objective to the screen. Write this program two ways:\n\n\nusing a for loop\n\n\nusing a while loop (hint: use the len() function to find out how many objectives there are\n\n\n\n# solution\nfor objective in course_objectives:\n    print(objective)\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n# solution\nnum_objectives = len(course_objectives)\ncount = 0\nwhile count &lt; num_objectives:\n    print(course_objectives[count])\n    count +=1\nwrite your own functions and packages in Python\nutilize class structures in Python to create reproducible, organized processes for data manupulation\nunderstand when to use functions and when to use classes\nsubmit a pull request to GitHub\ncreate clear and helpful documentation for your code\nuse the Pandas library to organize, manage, and manipulate data\nexplore a dataset visually with seaborn\ntell a story with data through effective visualizations\nwrite a complete Python package\n\n\n\nFunctions put together a number of operations and wrap them up in a neat package (so to speak). We will use functions often in this class, because they make it very easy to write flexible code that can be applied to a variety of data sets.\nIf you don’t remember how to write a function, definitely review your Python. Remember that a function must have a specific format. In its simplest form, this looks like\ndef function_name([optional input parameters]):\n    [code to execute]\n    return [value/variable etc]\nThe return statement is optional. Some functions just do things without returning any value. It’s up to you to decide what the best format is for a function you’re trying to write.\n\nExercise 9:\n\n\nwrite a function that takes as input a nested dictionary (like the one you created earlier for grades) prints the due date of that assignment\n\n\nwrite a function that takes as input a nested dictionary and one course component as a string and returns percent of the final grade that assignment is worth\n\n\n\n#solution\ndef what_percent(component, grade_dict):\n    grade_percent = (grade_dict[component]['grade fraction'])\n    return grade_percent\n#solution\nfp_grade = what_percent(\"Final project final draft\",grades_detailed)\nfp_grade\n0.2\n#solution\ndef when_is_this_due(component, grade_dict):\n    due_date = grade_dict[component]['due']\n    print(component+\" is due on \"+due_date)\n#solution\nwhen_is_this_due(\"Final project final draft\",grades_detailed)\nFinal project final draft is due on 12/14"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html",
    "href": "SDS271/F23/Lab2_solutions.html",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "This lab will dig a little more deeply into your previous Python experience as we examine two case studies in statistical simulations: the Monty Hall Problem and why the House always wins in gambling.\n\n\nWhat do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n1\n6\n4\n5\n3\n2\n3\n5\n1\n3\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\nheads\nheads\ntails\ntails\ntails\ntails\nheads\nheads\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\ntails\ntails\nheads\ntails\ntails\ntails\nheads\nheads\nheads\ntails\nheads\nheads\nheads\nheads\nheads\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.5, 'tails': 0.5}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.35, 'tails': 0.65}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nMonte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.5, 'tails': 0.5}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands -- it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\n#solution\nimport numpy as np\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\n#solution\nheads_array = np.array(heads_results)\ntails_array = np.array(tails_results)\nheads_avg = np.mean(heads_array)\ntails_avg = np.mean(tails_array)\nheads_sdev = np.std(heads_array)\ntails_sdev = np.std(tails_array)\n#solution\nprint(heads_avg)\nprint(tails_avg)\nprint(heads_sdev)\nprint(tails_sdev)\n0.498\n0.502\n0.1092291169972549\n0.1092291169972549\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\n#solution\nplt.hist(tails_results, color = 'gray',bins = 9)\nplt.axvline(x = tails_avg, color = 'r', label = 'mean result for tails')\nxmin = tails_avg - tails_sdev\nxmax = tails_avg + tails_sdev\nplt.axvspan(xmin,xmax, color='r', alpha=0.25)\nplt.show()\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\n#solution\nheads_err = heads_sdev/np.sqrt(len(heads_array))\ntails_err = tails_sdev/np.sqrt(len(tails_array))\n#solution\nprint(f\"The coin will land on heads {heads_avg*100}% plus or minus {heads_err*100}% of the time\")\nprint(f\"The coin will land on tails {tails_avg*100}% plus or minus {tails_err*100}% of the time\")\nThe coin will land on heads 49.8% plus or minus 0.3454127965203374% of the time\nThe coin will land on tails 50.2% plus or minus 0.3454127965203374% of the time\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n#solution\nplt.plot(np.cumsum(tails_results)/np.arange(1,len(tails_results)+1,1), color = \"gray\")\nplt.hlines(tails_avg,xmin = 0,xmax =len(tails_results),color = \"r\")\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\n\nLet’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n#solution\nresults_stay = []\nresults_change = []\nfor n in range(10):\n    MontyHall(doors, results_stay, results_change)\n    print(results_stay)\n['goat']\n['goat', 'car']\n['goat', 'car', 'car']\n['goat', 'car', 'car', 'car']\n['goat', 'car', 'car', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat', 'goat']\nresults_stay\nresults_change\n['car', 'goat', 'goat', 'goat', 'car', 'car', 'goat', 'car', 'car', 'car']\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use a modified version of the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks whether won by staying with your original door for “stay” or by changing to the other door for “change” for each experiment.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n#solution\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(1)\n        results_change.append(0)\n    else:\n        results_stay.append(0)\n        results_change.append(1)\n        \ndef MontyHallMC(n_MC):\n    results_stay = [] \n    results_change = []\n    for n in range(n_MC):\n        MontyHall(doors, results_stay, results_change)\n    results = {}\n    results[\"stay\"] = np.asarray(results_stay)\n    results[\"change\"] = np.asarray(results_change)\n    return results\n#solution\nresults_10 = MontyHallMC(10)\nplt.plot(np.cumsum(results_10[\"stay\"])/np.arange(1,len(results_10[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_10[\"change\"])/np.arange(1,len(results_10[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_100 = MontyHallMC(100)\nplt.plot(np.cumsum(results_100[\"stay\"])/np.arange(1,len(results_100[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_100[\"change\"])/np.arange(1,len(results_100[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_1000 = MontyHallMC(1000)\nplt.plot(np.cumsum(results_1000[\"stay\"])/np.arange(1,len(results_1000[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_1000[\"change\"])/np.arange(1,len(results_1000[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nLest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\n#solution\ndef roll():\n    r = rd.randrange(1,101)\n    if r &gt; 51:\n        return True\n    else:\n        return False\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\n#solution\ndef play_game(starting_funds,wager,num_plays):\n    outcomes = np.array([starting_funds])\n    funds = starting_funds\n    for n in range(num_plays):\n        if roll():\n            funds += wager\n        else:\n            funds -= wager\n        outcomes = np.append(outcomes,funds)\n    return outcomes\n#solution\nplay_game(100,10,10)\narray([100, 110, 100,  90, 100, 110, 100,  90,  80,  70,  80])\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n#solution\ndef MC_gambling(n_MC, starting_funds, wager, num_plays):\n    MC_outcomes = []\n    for n in range(n_MC):\n        outcomes = play_game(starting_funds,wager,num_plays)\n        plt.plot(outcomes, alpha = 0.25)\n        MC_outcomes.append(outcomes)\n    plays = np.arange(0,num_plays+1,1)\n    MC_avg = np.mean(MC_outcomes,axis = 0)\n    MC_err = np.std(MC_outcomes,axis = 0)/np.sqrt(n_MC)\n    plt.errorbar(x = plays, y = MC_avg, yerr = MC_err, color = \"black\")#, linestyle = \"dashed\")\n    plt.show()\n    plt.errorbar(x = plays, y= MC_avg, yerr = MC_err, color = \"black\")\n    plt.show()\n#solution\nn_MC = 1000\nstarting_funds = 100\nwager = 10\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?\n\n#solution\n#scenario 1\nstarting_funds = 10000\nwager = 100\nnum_plays = 5\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 2\nstarting_funds = 10000\nwager = 100\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 3\nstarting_funds = 1000\nwager = 100\nnum_plays = 100\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 4\nstarting_funds = 10000\nwager = 100\nnum_plays = 10000\nMC_gambling(n_MC, starting_funds, wager, num_plays)"
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#a-simple-scenario-flipping-a-coin",
    "href": "SDS271/F23/Lab2_solutions.html#a-simple-scenario-flipping-a-coin",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "What do you expect to happen if you flip a coin?\nThe answer depends on the possible outcomes and their likelihoods. This is the simplest way to express probability. A balanced coin has two unique sides (heads and tails) and each side has an equal likelihood of coming out on top if there is no bias in your toss (okay, so we are making a lot of simplifying assumptions). That means your total likelihood of 1 (or 100%) must be split evenly:\nP(heads) = 0.5\nP(tails) = 0.5\nEach individual coin toss contains an element of randomness. It doesn’t matter that you just got heads, you still have an even fifty-fifty chance to get gets again. But if you flip the coin many times, even if you get heads ten times in a row, you should still eventually get enough tails to even out the statistics so that roughly half your tosses come up heads and half come up tails.\n\n\nPython has a module that allows you to generate pseudo-random numbers. The world of random number generators is wide, but we’ll keep it simple for this class.\n\n\n\nSometimes we will need to use tools that aren’t in base Python. To do this, we will import other packages (or “modules”) that contain what we need. To import a module, you have to tell Jupyter to import the module, and then you can (optionally) tell the notebook how you’d like to call on this module so you don’t have to write out its whole name every time. For example, we will use the Numerical Python package called “numpy” often in this class. It’s standard to refer to numpy as “np” so we would import it like this:\nimport numpy as np\nThe “import numpy” instruction tells it to import the module known officially as numpy and the added “as np” instruction tells it that when you refer to np later, you mean numpy.\n\nExercise 1:\nImport the python random module with nickname “rd”\n\n#solution\nimport random as rd\nNow that you’ve imported the module, you can use it. But remember you have to call it using the nickname you gave it. So if I wanted to generate a random number between 0 and 1, I would use the random() function.\nrd.random()\n\n&gt; 0.42361251090879926\nYou can learn more about the module you just imported  here, including lots of other functions it contains that may be helpful in the upcoming activities.\n\nExercise 2:\nInvestigate the documentation for the Python random module and do the following: \n\nGenerate a random integer between 1 and 6 (inclusive)\n\n\nPick randomly from a list of “heads” and “tails”\n\n\nMake sure you repeat this enough times to be sure that it’s doing what you want it to (hint: write a for loop to repeat this process)\n\n#solution\nfor n in range(10):\n    print(rd.randrange(1,7,1))\n1\n6\n4\n5\n3\n2\n3\n5\n1\n3\n#solution\ncoin_list = [\"heads\",\"tails\"]\nfor n in range(10):\n    print(rd.choice(coin_list))\nheads\nheads\nheads\nheads\ntails\ntails\ntails\ntails\nheads\nheads\n\n\n\n\nExercise 3:\nWrite a simple function in Python that simulates flipping a coin. It should not take any arguments and it should return the outcome “heads” or “tails”.\n\n#solution\ndef coin_flip():\n    coin_sides = [\"heads\",\"tails\"]\n    return rd.choice(coin_sides)\n#solution\nfor n in range(20):\n    print(coin_flip())\ntails\nheads\ntails\nheads\ntails\ntails\nheads\ntails\ntails\ntails\nheads\nheads\nheads\ntails\nheads\nheads\nheads\nheads\nheads\nheads\nWhat is the probability of getting heads or tails? We have prior knowledge that tells us the answer here – it’s 50% for heads and 50% for tails. But how would we determine this experimentally? We can flip a coin many times and calculate what percentage of the time it came up with each option.\n\nExercise 4:\nWrite a simple function in Python that performs a coin flip some number of times and calculates the outcome. It should take as an argument the number of times you want to flip the coin, it should use your already-written coin-flip function, and it should return a dictionary with “heads” and “tails” as they keys and the fraction (decimal, not percent) of the times that that result occured.\nTest your function with 20 coin flips. Repeat this a few times, checking the results each time. What do you notice?\n\n#solution\ndef test_coin_flip(n_flips):\n    n_heads = 0\n    n_tails = 0\n    for n in range(n_flips):\n        if coin_flip() == \"heads\":\n            n_heads += 1\n        else:\n            n_tails += 1\n    return {\"heads\": n_heads/n_flips, \"tails\": n_tails/n_flips}\n#solution\nfor n in range(10):\n    print(test_coin_flip(20))\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.5, 'tails': 0.5}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.6, 'tails': 0.4}\n{'heads': 0.35, 'tails': 0.65}\n{'heads': 0.55, 'tails': 0.45}\n{'heads': 0.75, 'tails': 0.25}\n{'heads': 0.65, 'tails': 0.35}\n{'heads': 0.45, 'tails': 0.55}\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#monte-carlo-methods",
    "href": "SDS271/F23/Lab2_solutions.html#monte-carlo-methods",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Monte Carlo simulations take advantage of the law of large numbers and probabilities to simulate likely outcomes. It works by repeating small-scale experiments many times and averaging the results of those experiments.\nSo if you flipped a coin twenty times, you might get H/T = 0.4/0.6\nIf you did it again, you might get H/T = 0.75/0.25\nIf you did it a third time, maybe you’d get H/T = 0.55/0.45\nEach of these experiments doesn’t get you the full picture, but repeated many times, you can get a statistical estimate for the likely results of the experiment.\n\nExercise 5:\nRepeat your experiment of flipping a coin 20 times and save the results. Do this until you have 1000 sets of results saved as a nested dictionary.\n\n#solution\nresults = {}\nfor n in range(1000):\n    results[n] = test_coin_flip(20)\n#solution\nresults[0]\n{'heads': 0.5, 'tails': 0.5}\n\n\nWe’re going to add a new package to our repertoire…  matplotlib .\nThere’s a lot to learn with matplotlib, but we will start with simple plotting: we just want the pyplot sub-package for matplotlib. Generally, this is imported with the nickname “plt”\n\nExercise 6:\nImport matplotlib.pyplot with the nickname “plt”\n\n#solution\nimport matplotlib.pyplot as plt\nWe can use matplotlib to visualize the results of our 100 experiments.\n\nExercise 7:\nTake your results dictionary and – however is easiest for you – turn it into two lists: one that stores the results that are heads and one that stores the results that are tails.\nThen use the plt.hist(x) function to make two histograms – one for heads and one for tails.\nFinally, adjust the number of bins in your histogram by adding “bins =” after the data inside your histogram. For example:\nplt.hist(heads_results, bins = 10)\n\n\nHint: if you want to keep python from printing out information about your data and the plot, use plt.show() after your plot commands -- it cleans up the output.\n\n#solution\nheads_results = [results[i][\"heads\"] for i in results]\ntails_results = [results[i][\"tails\"] for i in results]\n#solution\nplt.hist(heads_results, bins = 10)\nplt.show()\n\n#solution\nplt.hist(tails_results, bins = 10)\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly.\n\n\n\n\nVisualizing the results can be useful, but we also want to know what this means numerically. What should you tell someone to expect if they plan to flip a coin twenty times? What is the likely range of outcomes they could experience? We can see from the plots that the most likely outcome is somewhere around 50/50, but that ratios of up to 30/70 are still fairly common. Almost never will the outcome of 20 coin flips be all heads or all tails. So let’s quantify this.\nWe’re going to use the package I mentioned earlier –  Numpy – to do this.\n\nExercise 8:\nImport numpy with the nickname “np”\n\n#solution\nimport numpy as np\nThe base “unit” of numpy is the numpy array. This is similar to a list in Python, but it’s much faster to use for calculations. Numpy uses vectorization to speed up all its internal functions.\nYou can convert a list to an array by using\nnp.array(list_name) \nOnce you have a numpy array, you can do a lot with it. We’re going to use  np.mean() ,  np.std() ,  np.sqrt() ,  np.arange() , and  np.cumsum()  today.\n\nExercise 9:\nConvert your two lists (heads results and tails results) to numpy arrays and calculate the mean and standard deviation of those results.\n\n#solution\nheads_array = np.array(heads_results)\ntails_array = np.array(tails_results)\nheads_avg = np.mean(heads_array)\ntails_avg = np.mean(tails_array)\nheads_sdev = np.std(heads_array)\ntails_sdev = np.std(tails_array)\n#solution\nprint(heads_avg)\nprint(tails_avg)\nprint(heads_sdev)\nprint(tails_sdev)\n0.498\n0.502\n0.1092291169972549\n0.1092291169972549\nLet’s add this information to the plot we already made. We made a histogram of the results of the heads experiments (stored in a numpy array called “heads_results”) like this:\nplt.hist(heads_results, bins = 10)\nplt.show()\nIf I want to add the mean as a vertical line, I can add a line of code after the hist() function but before plt.show():\nplt.hist(heads_results, bins = 10)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nplt.show()\nThis creates a vertical line at some position x = heads_avg, which is the variable I used to store the mean value of the array we histogrammed. I’ve set the color to blue and given it a label.\nIf I want to add information about the standard error, I can use the axvspan() function:\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\nThis fills the area on the plot between the x-values xmin and xmax, which I’ve calculated by finding the low end of our range (average minus error) and the high end of our range (average plus error). I picked the same color (blue) and set alpha (the opacity of the fill) to 0.25.\nplt.hist(heads_results, color = 'gray',bins = 9)\nplt.axvline(x = heads_avg, color = 'b', label = 'mean result for heads')\nxmin = heads_avg - heads_sdev\nxmax = heads_avg + heads_sdev\nplt.axvspan(xmin,xmax, color='b', alpha=0.25)\nplt.show()\n\n\nExercise 10:\nMake a plot like we did above, but for the results for tails, not heads. Use red as the color, and make the fill more transparent.\n\n#solution\nplt.hist(tails_results, color = 'gray',bins = 9)\nplt.axvline(x = tails_avg, color = 'r', label = 'mean result for tails')\nxmin = tails_avg - tails_sdev\nxmax = tails_avg + tails_sdev\nplt.axvspan(xmin,xmax, color='r', alpha=0.25)\nplt.show()\n\nThe standard deviation tells us how much we might expect any given experiment to deviate from the average. But if we wanted to give an answer to how often a coin landed on heads, with error, we would use the standard error, not the standard deviation.\n\\(\\sigma = \\frac{1}{\\sqrt{N}}\\text{SD}\\)\nWhere \\(\\sigma\\) is the standard error, \\(N\\) is the number of times we repeated our experiment, and SD is the standard deviation.\n\nExercise 11:\nFind the fraction of times a flipped coin will land on heads, with the standard error. Repeat for tails.\nHint: you can use len() to determine the number of elements in a numpy array, just like you can with a Python list.\n\n#solution\nheads_err = heads_sdev/np.sqrt(len(heads_array))\ntails_err = tails_sdev/np.sqrt(len(tails_array))\n#solution\nprint(f\"The coin will land on heads {heads_avg*100}% plus or minus {heads_err*100}% of the time\")\nprint(f\"The coin will land on tails {tails_avg*100}% plus or minus {tails_err*100}% of the time\")\nThe coin will land on heads 49.8% plus or minus 0.3454127965203374% of the time\nThe coin will land on tails 50.2% plus or minus 0.3454127965203374% of the time\nLet’s take a look now at how the Monte Carlo method (the repeated experiments) gets us from something with a relatively wide distribution to something with very high accuracy (hint: the more you do, the better it gets)\nplt.plot(np.cumsum(heads_results)/np.arange(1,len(heads_results)+1,1), color = \"gray\")\nplt.hlines(heads_avg,xmin = 0,xmax =len(heads_results),color = \"b\")\nplt.show()\n\nAll I’ve done here is plot the cumulative average of the results of our experiments for “heads.” I did this using the built-in cumulative sum function and dividing that array by an array that shows the number of experiments completed up to that point (1, then 2, then 3, all the way up to the final number of 1000).\nWe can see a lot of initial variation in our results, but eventually the average levels out to something very consistent.\nThis is the power of the Monte Carlo simulation – the larger the number of experiments, the better the results.\n\nExercise 12:\nRepeat the process above to make a plot that shows the cumulative average for the results for tails, along with the final average value. Use red to indicate the average value for tails.\n\n#solution\nplt.plot(np.cumsum(tails_results)/np.arange(1,len(tails_results)+1,1), color = \"gray\")\nplt.hlines(tails_avg,xmin = 0,xmax =len(tails_results),color = \"r\")\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#the-monty-hall-problem",
    "href": "SDS271/F23/Lab2_solutions.html#the-monty-hall-problem",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Let’s look at a famous riddle that involves statistics and answer it using Monte Carlo methods.\nSuppose you are on a game show, and you have the choice of picking one of three doors: Behind one door is a car; behind the other doors, goats. You pick a door, let’s say door 1, and the host, who knows what’s behind the doors, opens another door, say door 3, which has a goat. The host then asks you: do you want to stick with your choice or choose another door?\nLet’s start by setting up our problem. We have three doors, two of which have goats behind them and one of which has a car behind it. We can represent that as a list.\nWe then initialize some lists to track what happens if we stay and what happens if we change our minds.\ndoors = [\"car\",\"goat\",\"goat\"]\nresults_stay = []\nresults_change = []\nWe then write a simple function that takes our doors, makes a random selection, and then returns the results in the following way: if our first choice happens to be the door with the car behind it, we win if we stay! So our “stay” results are “car” and our “change” results are goat. If the first choice happens to have a goat behind it, then staying gives us a goat, while changing gives us a car.\nNote that it’s important to keep our results straight. We could write a function that looks like this:\ndef MontyHall(doors):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        return \"car\", \"goat\"\n    else:\n        return \"goat\", \"car\"\nbut then we would have to make sure that we assigned the output in the right order, i.e.\nresults_stay.append(MontyHall(doors)[0])\nresults_change.append(MontyHall(doors)[1])\nIt’s easier to keep track of your results by modifying the lists within the function.\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(\"car\")\n        results_change.append(\"goat\")\n    else:\n        results_stay.append(\"goat\")\n        results_change.append(\"car\")\n\nExercise 13:\nTest this function. Does it do what you expect? Do you understand the output?\n\n#solution\nresults_stay = []\nresults_change = []\nfor n in range(10):\n    MontyHall(doors, results_stay, results_change)\n    print(results_stay)\n['goat']\n['goat', 'car']\n['goat', 'car', 'car']\n['goat', 'car', 'car', 'car']\n['goat', 'car', 'car', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat']\n['goat', 'car', 'car', 'car', 'goat', 'goat', 'car', 'goat', 'goat', 'goat']\nresults_stay\nresults_change\n['car', 'goat', 'goat', 'goat', 'car', 'car', 'goat', 'car', 'car', 'car']\n\nExercise 14:\nCreate a function that performs a Monte Carlo simulation for this scenario. It should use a modified version of the Monty Hall function we wrote above, and you can assume one “choice” is one experiment.\nYour function should take as an argument the number of Monte Carlo iterations you want to do. It should return a dictionary with two keys: “stay” and “change” whose values are a numpy array that tracks whether won by staying with your original door for “stay” or by changing to the other door for “change” for each experiment.\nHint: you may want to modify the MontyHall function we wrote above to make the results numerical, for example, 1 for a car and 0 for a goat.\nRun this function for 10, 100, and 1000 iterations and plot the results for each, similarly to how we plotted the heads/tails results. Show us the cumulative average of wins for “stay” and “change” each, but put them both on the same plot (you don’t need to plot the overall average for each, just the cumulative average)\n\n#solution\ndef MontyHall(doors, results_stay, results_change):    \n    rd.shuffle(doors)\n    first_door = rd.choice(doors)\n    if first_door == \"car\":\n        results_stay.append(1)\n        results_change.append(0)\n    else:\n        results_stay.append(0)\n        results_change.append(1)\n        \ndef MontyHallMC(n_MC):\n    results_stay = [] \n    results_change = []\n    for n in range(n_MC):\n        MontyHall(doors, results_stay, results_change)\n    results = {}\n    results[\"stay\"] = np.asarray(results_stay)\n    results[\"change\"] = np.asarray(results_change)\n    return results\n#solution\nresults_10 = MontyHallMC(10)\nplt.plot(np.cumsum(results_10[\"stay\"])/np.arange(1,len(results_10[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_10[\"change\"])/np.arange(1,len(results_10[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_100 = MontyHallMC(100)\nplt.plot(np.cumsum(results_100[\"stay\"])/np.arange(1,len(results_100[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_100[\"change\"])/np.arange(1,len(results_100[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n#solution\nresults_1000 = MontyHallMC(1000)\nplt.plot(np.cumsum(results_1000[\"stay\"])/np.arange(1,len(results_1000[\"stay\"])+1,1), color = \"r\", label = \"stay\")\nplt.plot(np.cumsum(results_1000[\"change\"])/np.arange(1,len(results_1000[\"change\"])+1,1), color = \"b\", label = \"change\")\nplt.legend()\nplt.show()\n\n\nStop here for a minute. Check-in with  slido and then wait. Work on something else, help your neighbor, etc. We will be returning to this lab shortly."
  },
  {
    "objectID": "SDS271/F23/Lab2_solutions.html#why-the-house-always-wins",
    "href": "SDS271/F23/Lab2_solutions.html#why-the-house-always-wins",
    "title": "Lab 2 solutions: Statistics and Betting",
    "section": "",
    "text": "Lest you start to think your insider knowledge of statistics is going to give you the upper hand at the casino, let’s talk about how to use Monte Carlo methods to demonstrate that the house always (on average) wins.\n\n\nConsider an imaginary game in which our player, rolls an imaginary dice to get an outcome of 1 to 100. If the player rolls anything from 1–51, the house wins, but if the number rolled is from 52–100, the player wins.\nThe house edge displays the advantage the casino has in winning the bet. It’s the casino’s average profit from a player’s bet.\nLet’s suppose our player bets 1 dollar on this game.\n\\(P(player\\ wins) = 49/100,\\ P(casino\\ wins)= 51/100\\)\n\\(E(player\\ profit)= 1*(49/100)-1*(51/100) = -0.02 = -2\\%\\)\nTherefore, the house edge in our imaginary game is 2%.\n(This isn’t just because of our fictional scenario – you can see some house edges  here  to see how our game compares. We are actually being quite generous to our fictional player)\n\n\n\nWe need a dice simulator which throws a value from 1–100 with uniform probability distribution.\n\nExercise 15:\nCreate a function to simulate the dice throw above and return the boolean operator True if the player wins and False if the casino wins.\n\n#solution\ndef roll():\n    r = rd.randrange(1,101)\n    if r &gt; 51:\n        return True\n    else:\n        return False\nNow that we’ve simulated the roll, we need to simulate the betting process. This is a little more complicated, but we can use the equation for expected profit above to help us out. We should consider three things:\n\nStarting funds : The money the player is starting with\nWager Amount : The amount the player bets in each game\nTotal plays : The number of times the player plays the game (This value is changed for creating different scenarios)\n\n\nExercise 16:\nCreate a function that simulates (multiple) bets. It should take as input the starting funds, the wager amount (for the sake of simplicity, let’s say the player bets the same amount on each play), and the number of plays.\nThis function should track the amount of money the player has after each play, from start to end. Let’s assume that number can become negative (i.e. they can rack up a debt to the casino). It should return an array with those amounts.\nDon’t forget to test that function – make sure it’s doing what you want.\n\n#solution\ndef play_game(starting_funds,wager,num_plays):\n    outcomes = np.array([starting_funds])\n    funds = starting_funds\n    for n in range(num_plays):\n        if roll():\n            funds += wager\n        else:\n            funds -= wager\n        outcomes = np.append(outcomes,funds)\n    return outcomes\n#solution\nplay_game(100,10,10)\narray([100, 110, 100,  90, 100, 110, 100,  90,  80,  70,  80])\nNow, remember we are looking for average behavior. Hopefully you noticed in testing your function that sometimes the player emerges with more money than they started with! That’s the allure of gambling! But hopefully you also noticed that most often, the player ends at a loss.\nIf we want to know how this looks to the house, what we need to do is simulate many many scenarios and see what the average result is (and how large the error is on that result). That’s just a Monte Carlo simulation (aptly named).\n\nExercise 17:\nWrite a function that does a Monte Carlo simulation of playing the game with a fixed starting amount, wager amount, and number of plays.\nRemember to run the simulation many times (let’s go with 1,000).\nPlot the outcomes – it can help to show the individual scenarios alongside the average (in a different color, and/or with an alpha less than 1 so we can see how all the varied outcomes contribute to the overall average. You can include this plot as part of your MC function or you can write it separately.\n\n#solution\ndef MC_gambling(n_MC, starting_funds, wager, num_plays):\n    MC_outcomes = []\n    for n in range(n_MC):\n        outcomes = play_game(starting_funds,wager,num_plays)\n        plt.plot(outcomes, alpha = 0.25)\n        MC_outcomes.append(outcomes)\n    plays = np.arange(0,num_plays+1,1)\n    MC_avg = np.mean(MC_outcomes,axis = 0)\n    MC_err = np.std(MC_outcomes,axis = 0)/np.sqrt(n_MC)\n    plt.errorbar(x = plays, y = MC_avg, yerr = MC_err, color = \"black\")#, linestyle = \"dashed\")\n    plt.show()\n    plt.errorbar(x = plays, y= MC_avg, yerr = MC_err, color = \"black\")\n    plt.show()\n#solution\nn_MC = 1000\nstarting_funds = 100\nwager = 10\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n\n\n\n\nExercise 18:\nTry your function out on the following scenarios:\nScenario 1: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 5\nScenario 2: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10\nScenario 3: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 100\nScenario 4: * Starting funds: 10000 * Wager amount: 100 * Number of bets : 10000\nPlot the individual outcomes and average result from each simulation. What do you notice?\n\n#solution\n#scenario 1\nstarting_funds = 10000\nwager = 100\nnum_plays = 5\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 2\nstarting_funds = 10000\nwager = 100\nnum_plays = 10\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 3\nstarting_funds = 1000\nwager = 100\nnum_plays = 100\nMC_gambling(n_MC, starting_funds, wager, num_plays)\n\n\n#solution\n#scenario 4\nstarting_funds = 10000\nwager = 100\nnum_plays = 10000\nMC_gambling(n_MC, starting_funds, wager, num_plays)"
  },
  {
    "objectID": "sds-271-f23.html#lab-3",
    "href": "sds-271-f23.html#lab-3",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 3",
    "text": "Lab 3\nLab 3 introduces the data science package Pandas, which allows you to organize, filter, sort, and do simple statistics on large datasets."
  },
  {
    "objectID": "SDS271/F23/Lab3_clean.html",
    "href": "SDS271/F23/Lab3_clean.html",
    "title": "Lab 3: Intro to Pandas",
    "section": "",
    "text": "Exercise 1: Import the following packages that you’ve already seen to this notebook:\n\n\nnumpy (as np)\n\n\npyplot from matplotlib (as plt)\n\n\n\n\nExercise 2:\nNow, import this new package called Pandas. Traditionally, it’s imported with “nickname” pd\nimport pandas as pd\n\n\n\nThe heart of Pandas is an object called a “Series.” This is kind of like a numpy array, but with the labeling of a dictionary.\n\nExercise 3:\nGenerate a numpy array of random numbers of some medium-sized length (say, 30 - you can do this with numpy or with the random module you’ve imported for previous labs. Note that you will need to import random if you want to use that module, but numpy is already imported.\nNow that you have the numpy array, convert it to a pandas Series using the pd.Series() function.\nFinally, explore that series. If you look at the Series documentation, you will see that a Series type has dozens of built-in function you can use. To simplify, start with:\n\n\ndescribe()\n\n\nhead()\n\n\ntail()\n\n\ncount()\n\n\none additional function of your choice from the list on the left of the documentation\n\n\nNote: you can also convert this series back to a numpy array using the to_numpy() function!\n\n\n\nYou can also make a series from a dictionary. In Moodle, you will find a link to a Google Sheet which stores the information we gathered on the first day of class: names, majors and minors, class year, and hometown.\n\nExercise 3:\nGo to the Google Sheet and take a look. Then make a dictionary: the key should be the name (combine first and last here to avoid duplicates) and the value should be the class year (e.g. for Casey, we need to use “np.NAN” to indicate there is no number). Name this dictionary whatever you want.\nThen, use the pd.Series() function to convert this dictionary to a series. Examine it just as you examined the other string – what is different?\n\nBe careful with indexing in pandas series. It’s more like a dictionary than an array. To find the ith element, use the iloc attribute, for example (I named my series “class_year”):\nclass_year.iloc[4]\nIn general, it’s better to use keys and .loc than indexing and .iloc. If I want to find what my class year is, I would do:\nclass_year[\"Casey Berger\"]\n\n&gt; 'NaN'\nThis is fine to do in a simple dataset, but the best practice is to use .loc:\nclass_year.loc[\"Casey Berger\"]\n\n\n\nYou can filter a series by index or by values. For example, maybe I only want the list of seniors graduating in May in the class. That’s class year 2024. I can create a “mask” that will select only students with that class year:\nsenior_mask = class_year == 2024\nsenior_mask\nDon’t forget that in Python, a single equals sign is an assignment while a double equals sign insists on equivalence!\nIf you print the mask, you can see that it’s created a boolean filter – everything is either “true” if the class year is 2024 or “false” otherwise.\nNow, I can filter the list by plugging that “mask” into the series:\nseniors = class_year[senior_mask]\nprint(seniors)\nYou can use masks with the .loc technique as well (for more details, including an explanation of the difference between .loc and .iloc, check out this great article from Towards Data Science), so you will want to work with this formulation when you are doing complicated, multi-step filtering, cleaning, and manipulating on a dataset.\nseniors = class_year.loc[senior_mask]\nprint(seniors)\n\nExercise 4:\nCreate a mask that filters the series by students that are graduating AFTER spring 2024 (all non-seniors).\n\n\nStop when you get here. Check in with  slido, then help your neighbor, work on a project, etc.\n\n\n\n\n\nA DataFrame is a stack of Series. While every object in a series must have the same type, you can stack together series of different types to make a dataframe. You can filter dataframes just like you can filter series, and the use of keys can be very helpful here!\nWith series, we created them from numpy arrays and dictionaries, but most of the time with dataframes, we will start by importing a file (most often .csv). This is very easy to do in Pandas.\n\nExercise 5:\nUpload the .csv file in Moodle (this is the same data as the Google sheet) to your JupyterHub in the same directory as this notebook. Then, create a dataframe (let’s call it “class_data” for simplicity) using the read_csv function.\nclass_data = pd.read_csv(\"SDS271_class_data.csv\")\nYou can use many of the same functions to examine a dataframe as a series: try this with describe(), head(), and tail()\nBut there’s more going on here. Try the following:\nclass_data.columns\nclass_data.dtypes\nclass_data.shape\n\nNow, I can filter this data, but I need to specify which column (or series) my filter applies to.\nnon_senior_mask = class_data[\"Class year\"] &gt; 2024\nnon_senior_df = class_data[non_senior_mask]\nnon_senior_df\n\nExercise 6:\nTry creating some masks for this dataframe. What are some of the limitations you encounter as you try to filter things?\n\n\nOnce you’ve got the hang of making masks, check-in with  slido. Then, make some more masks, help your neighbor, whatever will help you get more comfortable with this material.\n\n\n\n\n\nWhen working with small, simple datasets, we can use reasonably simple operations. But as our datasets get larger and more complicated, we need to use new methods to ensure that we are making the changes we expect.\nTo learn some of these techniques, we are going to use a new dataset.\n\nExercise 7:\nDownload the Pokemon dataset from Moodle and read it in here. Take a few minutes to explore the dataset. What do you notice about it? What is in it? How is it organized?\nDiscuss with your neighbor for a few minutes. Together, come up with a way to answer this question: what is the most common primary type of the Pokemon in the dataset?\n\n\n\nMotivating question: What is the most common ability among the Pokemon in our dataset?\n\nExercise 8:\nTry using the same method you used to find the most common type to determine the most common ability. What goes wrong?\n\n\nDescribe this to the best of your ability in  sli.do. You can answer together with your neighbor if you want.\n\nLet’s take a closer look at the column together to see what’s happening.\nWhat is the type of these entries? Pandas says object, which often means string. Let’s check with Python.\nWe need to use the Python eval function here to read the string as a list. We can do this by applying the eval function to each entry in the column.\npk_df.loc[:,\"abilities\"].apply(eval)\npk_df.loc[:,\"abilities\"] = pk_df.loc[:,\"abilities\"].apply(eval)\npk_df[\"abilities\"]\nNow that we have a list object instead of a string, we can use value_counts. But first, we have to use the explode function so that it pulls out each entry in each list and counts it separately. We can chain these operations together.\npk_df[\"abilities\"].explode().value_counts()\n\n\n\nWe’ve now been able to determine the most common abilities in the dataset, but how many abilities does each Pokemon have on average? Do they all have the same number, or does it vary? We can create a new column with this information using a lambda function and apply.\nnote: you can define a whole function yourself to apply here, but it’s shorter and more efficient to use a lambda function\npk_df.loc[:,\"num_abilities\"] = pk_df.apply(lambda x: len(x['abilities']),axis = 1)\nAlternative version:\ndef count_abilities(x):\n    return len(x[\"abilities\"])\n\npk_df.loc[:,\"num_abilities_alt\"] = pk_df.apply(count_abilities,axis = 1)\nIf you want, try both versions and see that they do the same thing. If you are more comfortable defining a function and applying it than using lambda functions, that is okay. But over time, you should start to get more comfortable with lambda functions."
  },
  {
    "objectID": "SDS271/F23/Lab3_clean.html#pandas-basic-structures-and-operations",
    "href": "SDS271/F23/Lab3_clean.html#pandas-basic-structures-and-operations",
    "title": "Lab 3: Intro to Pandas",
    "section": "",
    "text": "Exercise 1: Import the following packages that you’ve already seen to this notebook:\n\n\nnumpy (as np)\n\n\npyplot from matplotlib (as plt)\n\n\n\n\nExercise 2:\nNow, import this new package called Pandas. Traditionally, it’s imported with “nickname” pd\nimport pandas as pd\n\n\n\nThe heart of Pandas is an object called a “Series.” This is kind of like a numpy array, but with the labeling of a dictionary.\n\nExercise 3:\nGenerate a numpy array of random numbers of some medium-sized length (say, 30 - you can do this with numpy or with the random module you’ve imported for previous labs. Note that you will need to import random if you want to use that module, but numpy is already imported.\nNow that you have the numpy array, convert it to a pandas Series using the pd.Series() function.\nFinally, explore that series. If you look at the Series documentation, you will see that a Series type has dozens of built-in function you can use. To simplify, start with:\n\n\ndescribe()\n\n\nhead()\n\n\ntail()\n\n\ncount()\n\n\none additional function of your choice from the list on the left of the documentation\n\n\nNote: you can also convert this series back to a numpy array using the to_numpy() function!\n\n\n\nYou can also make a series from a dictionary. In Moodle, you will find a link to a Google Sheet which stores the information we gathered on the first day of class: names, majors and minors, class year, and hometown.\n\nExercise 3:\nGo to the Google Sheet and take a look. Then make a dictionary: the key should be the name (combine first and last here to avoid duplicates) and the value should be the class year (e.g. for Casey, we need to use “np.NAN” to indicate there is no number). Name this dictionary whatever you want.\nThen, use the pd.Series() function to convert this dictionary to a series. Examine it just as you examined the other string – what is different?\n\nBe careful with indexing in pandas series. It’s more like a dictionary than an array. To find the ith element, use the iloc attribute, for example (I named my series “class_year”):\nclass_year.iloc[4]\nIn general, it’s better to use keys and .loc than indexing and .iloc. If I want to find what my class year is, I would do:\nclass_year[\"Casey Berger\"]\n\n&gt; 'NaN'\nThis is fine to do in a simple dataset, but the best practice is to use .loc:\nclass_year.loc[\"Casey Berger\"]\n\n\n\nYou can filter a series by index or by values. For example, maybe I only want the list of seniors graduating in May in the class. That’s class year 2024. I can create a “mask” that will select only students with that class year:\nsenior_mask = class_year == 2024\nsenior_mask\nDon’t forget that in Python, a single equals sign is an assignment while a double equals sign insists on equivalence!\nIf you print the mask, you can see that it’s created a boolean filter – everything is either “true” if the class year is 2024 or “false” otherwise.\nNow, I can filter the list by plugging that “mask” into the series:\nseniors = class_year[senior_mask]\nprint(seniors)\nYou can use masks with the .loc technique as well (for more details, including an explanation of the difference between .loc and .iloc, check out this great article from Towards Data Science), so you will want to work with this formulation when you are doing complicated, multi-step filtering, cleaning, and manipulating on a dataset.\nseniors = class_year.loc[senior_mask]\nprint(seniors)\n\nExercise 4:\nCreate a mask that filters the series by students that are graduating AFTER spring 2024 (all non-seniors).\n\n\nStop when you get here. Check in with  slido, then help your neighbor, work on a project, etc.\n\n\n\n\n\nA DataFrame is a stack of Series. While every object in a series must have the same type, you can stack together series of different types to make a dataframe. You can filter dataframes just like you can filter series, and the use of keys can be very helpful here!\nWith series, we created them from numpy arrays and dictionaries, but most of the time with dataframes, we will start by importing a file (most often .csv). This is very easy to do in Pandas.\n\nExercise 5:\nUpload the .csv file in Moodle (this is the same data as the Google sheet) to your JupyterHub in the same directory as this notebook. Then, create a dataframe (let’s call it “class_data” for simplicity) using the read_csv function.\nclass_data = pd.read_csv(\"SDS271_class_data.csv\")\nYou can use many of the same functions to examine a dataframe as a series: try this with describe(), head(), and tail()\nBut there’s more going on here. Try the following:\nclass_data.columns\nclass_data.dtypes\nclass_data.shape\n\nNow, I can filter this data, but I need to specify which column (or series) my filter applies to.\nnon_senior_mask = class_data[\"Class year\"] &gt; 2024\nnon_senior_df = class_data[non_senior_mask]\nnon_senior_df\n\nExercise 6:\nTry creating some masks for this dataframe. What are some of the limitations you encounter as you try to filter things?\n\n\nOnce you’ve got the hang of making masks, check-in with  slido. Then, make some more masks, help your neighbor, whatever will help you get more comfortable with this material."
  },
  {
    "objectID": "SDS271/F23/Lab3_clean.html#more-advanced-operations-with-pandas",
    "href": "SDS271/F23/Lab3_clean.html#more-advanced-operations-with-pandas",
    "title": "Lab 3: Intro to Pandas",
    "section": "",
    "text": "When working with small, simple datasets, we can use reasonably simple operations. But as our datasets get larger and more complicated, we need to use new methods to ensure that we are making the changes we expect.\nTo learn some of these techniques, we are going to use a new dataset.\n\nExercise 7:\nDownload the Pokemon dataset from Moodle and read it in here. Take a few minutes to explore the dataset. What do you notice about it? What is in it? How is it organized?\nDiscuss with your neighbor for a few minutes. Together, come up with a way to answer this question: what is the most common primary type of the Pokemon in the dataset?\n\n\n\nMotivating question: What is the most common ability among the Pokemon in our dataset?\n\nExercise 8:\nTry using the same method you used to find the most common type to determine the most common ability. What goes wrong?\n\n\nDescribe this to the best of your ability in  sli.do. You can answer together with your neighbor if you want.\n\nLet’s take a closer look at the column together to see what’s happening.\nWhat is the type of these entries? Pandas says object, which often means string. Let’s check with Python.\nWe need to use the Python eval function here to read the string as a list. We can do this by applying the eval function to each entry in the column.\npk_df.loc[:,\"abilities\"].apply(eval)\npk_df.loc[:,\"abilities\"] = pk_df.loc[:,\"abilities\"].apply(eval)\npk_df[\"abilities\"]\nNow that we have a list object instead of a string, we can use value_counts. But first, we have to use the explode function so that it pulls out each entry in each list and counts it separately. We can chain these operations together.\npk_df[\"abilities\"].explode().value_counts()\n\n\n\nWe’ve now been able to determine the most common abilities in the dataset, but how many abilities does each Pokemon have on average? Do they all have the same number, or does it vary? We can create a new column with this information using a lambda function and apply.\nnote: you can define a whole function yourself to apply here, but it’s shorter and more efficient to use a lambda function\npk_df.loc[:,\"num_abilities\"] = pk_df.apply(lambda x: len(x['abilities']),axis = 1)\nAlternative version:\ndef count_abilities(x):\n    return len(x[\"abilities\"])\n\npk_df.loc[:,\"num_abilities_alt\"] = pk_df.apply(count_abilities,axis = 1)\nIf you want, try both versions and see that they do the same thing. If you are more comfortable defining a function and applying it than using lambda functions, that is okay. But over time, you should start to get more comfortable with lambda functions."
  },
  {
    "objectID": "sds-271-f23.html#lab-4",
    "href": "sds-271-f23.html#lab-4",
    "title": "SDS 271 Fall 2023",
    "section": "Lab 4",
    "text": "Lab 4\nLab 4 digs deeper into pandas and matplotlib using data from nuclear physics. It also introduces the seaborn visualization package."
  },
  {
    "objectID": "SDS271/F23/Lab4_clean.html",
    "href": "SDS271/F23/Lab4_clean.html",
    "title": "Lab 4: Data Science Libraries in Python",
    "section": "",
    "text": "Note: parts of this lab were adapted from the  DSECOP module “Introduction to Data Science Libraries: Using Pandas, Matplotlib, and Seaborn to Analyze Physics Data” by  Julie Butler.\nThe goal of this notebook is to introduce you to three libraries that are commonly used in data science to analyze, format, and display data sets that are stored in files. The second half of this notebook is also framed around exploring data sets specific to physics.\n\n\nThis notebook will introduce you to three libraries commonly used in data science and help analyze physics data. Pandas (which you have already seen) provide ways to easily import data from a file and save it a Pandas Dataframe, which allows us to easily display the data as a table, access the different columns of data, and begin formatting the data for later analysis. The other two libraries used in this notebook, Seaborn and Matplotlib (which you’ve also seen already), are used to create graphs from the data set. We will learn about Seaborn and dig into more advanced plotting with Matplotlib in this lab. Each graphing library has its strengths and reasons to use, which will be discussed later in the notebook.\nIt maybe easier to think about these libraries by thinking about their relationships to each other. NumPy, one of the standard Python libraries, provides an implementation of a data structure called arrays, which allows us to easily manipulate one and two dimensional data sets. However, it can be hard to display a matrix of data and extract different column, especially since NumPy does not provide headers for its columns. Pandas is simply a wrapper for NumPy arrays which provides an easy way to display, access, and manipulate two dimensional data sets. However, underneath the hood it is simply using NumPy arrays.\nLikewise, Matplotlib is the simplest graphing library avaliable in Python and its default graphs are quite plain. Seaborn is a wrapper of the Matplotlib class which adds more formatting to the default graphs and also provides the creation of some compound graphs, such as pairplot that we will look at below.\n\n\n\nThe data set we will investigate in this notebook contains the following data for every measurable isotope: number of neutrons, number of protons, number of nucleons, binding energy, the uncertainty of binding energy measurement, atomic mass, and uncertainty on mass measurement. This notebook section will help you better understand this data set and why nuclear scientists may want to study it.\n\n\nThe nucleus of an atom contains two types of particles: positively charged particles called protons and neutral particles called neutrons. The total number of protons in the nucleus is Z, and the total number of neutrons is N. Protons and neutrons are both types of nucleons, so the total number of nucleons in the nucleus is A = Z + N.\nThe number of protons in the nucleus determines what element it is. For example, all nuclei with 12 protons are carbon nuclei, all nuclei with 1 proton are hydrogen, and all nuclei with 20 protons are calcium. However, the number of neutrons in a nucleus does not define an element. So there are carbon atoms with 11 neutrons, 12 neutrons, 13 neutrons, and so on. Nuclei that have the same number of protons but different numbers of neutrons are referred to as isotopes of each other.\n\n\n\nAn atom’s atomic mass is the atom’s total mass (i.e., the nucleus and the protons). Note that it is not the same as the sum of the masses of the particles that make up the atom. This will be explored in the next section.\n\n\n\nThe mass of an atomic nucleus will be less than the total mass of its constituent particles. This difference in mass is called the binding energy, as it is the energy required to hold the atom together. Remember that mass and energy are related by the famous equation from Einstein: \\(E = mc^2\\).\nTo calculate the theoretical binding energies using Einstein’s equation, we can define the binding energy as:\n\\[BE = Mc^2 - mc^2,\\]\nwhere M is the total mass of all of the particles in the atom, m is the actual atomic mass of the atom, and c is the speed of light in a vacuum. We can define M as:\n\\[M = Z(m_p + m_e) + Nm_n,\\]\nwhere m\\(_p\\) is the mass of a proton, m\\(_e\\) is the mass of an electron, and m\\(_n\\) is the mass of a neutron. So, we can rewrite the binding energy as:\n\\[BE = ((m_p + m_e)Z + m_nN - m)c^2.\\]\nNext, we can define the atomic mass of hydrogen as one proton plus one electron: \\[m_h = m_p + m_e,\\]\nwhich means we can rewrite the binding energy as:\n\\[BE = (m_hZ + m_nN - m)c^2,\\]\nwhere \\(m_h\\) = 1.007 MeV, \\(m_n\\) = 1.008 MeV and \\(c^2\\) = 931.49 MeV/u.\nThe binding energies in the data set are experimental binding energies. Later in this notebook, we will determine how well the experimental binding energies correspond to the theoretical ones we defined in this section.\n\n\n\nThe atomic masses and binding energies in this data set were collected through experiments. Any data collected through experimentation has uncertainty in it. Though these are usually relatively small, they are also presented in this data set.\n\n\n\n\n\n\nExercise 1: Import the following packages that you’ve already seen to this notebook:\n\n\nnumpy (as np)\n\n\npyplot from matplotlib (as plt)\n\n\npandas (as pd)\n\n\n\n\nThe data set is saved in the file “NuclearData.tsv”, which you can find in Moodle. Upload that file to the same directory in JupyterHub where you have this notebook saved.\nWe’re going to read in this data using the read_csv() function that you used in the last lab. But note that the data is a “.tsv” file, which means the data is separated by tabs and not commas.\n\nExercise 2:\nRead the documentation for the  read_csv() function and figure out what you need to do to make this work for a tab-separated file. Then, import the data into a dataframe – call this dataframe “nuclear_data” as we will be working with a mix of examples and exercises and it will be easiest if we all use the same name.\nHint: remember the regex shorthands you learned in SDS 192.\n\nFirst, lets confirm that nuclear_data is a Pandas Dataframe by printing its type.\ntype(nuclear_data)\npandas.core.frame.DataFrame\nNow lets print nuclear_data to see what the DataFrame looks like.\nNote, you can also print just the head() or tail(), and if you have a very large DataFrame, it will be easier to do that if you just want to see the basic structure. But let’s go ahead and print the whole thing.\nnuclear_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.0\n0.0\n1008664.91582\n0.00049\n\n\n1\n0\n1\n1\nH\n0.0\n0.0\n1007825.03224\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.000\n2014101.77811\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.000\n3016049.28199\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.000\n3016029.32265\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3431\n176\n117\n293\nEh\n7095#\n3#\n293208680#\n870#\n\n\n3432\n175\n118\n293\nEi\n7077#\n2#\n293213498#\n753#\n\n\n3433\n177\n117\n294\nEh\n7092#\n2#\n294210974#\n708#\n\n\n3434\n176\n118\n294\nEi\n7079#\n2#\n294214132#\n712#\n\n\n3435\n177\n118\n295\nEi\n7075#\n2#\n295216332#\n692#\n\n\n\n\n3436 rows × 8 columns\n\n\nA DataFrame allows us to easily display the different columns and rows of the data file in a table. It even used the column labels from the data file to name the other columns.\nThe columns from left to right are the number of neutrons, number of protons, number of nucleons (i.e., the total number of protons and neutrons or A = N+Z), the elemental symbol, the binding energy per nucleon, the uncertainty on the binding energy, the atomic mass, and the uncertainty on the atomic mass.\n\n\n\nA Pandas Dataframe can behave like a dictionary where the column headings are the keys, and the columns are the values.\nLast lab, we used .columns to print the columns, but we can do this another way as well, using the .keys() function, just like with a dictionary.\nWhy bother with two actions that do the same thing? A Pandas dataframe is an object, which means it has attributes and built in functions. Things like .columns and .shape return attributes of the object, while things like .keys() and .head() perform some action defined by an internal function.\n\nExercise 3:\nPrint the list of the columns in this dataframe using both methods: .columns and .keys() and verify that they give you the same thing.\n\n\nExercise 4:\nExplore accessing the various columns of data using the column headers. Make sure you can access all of the different columns.\n\n\n\n\nAfter a data set is imported, we need to start formatting it so it’s ready for analysis. Most of the time, this will include ensuring the data is the correct type (i.e., numeric or words) and that every entry in the Dataframe is filled out. Every column of the Dataframe should be numeric except for the element symbol. However, when nuclear_data is printed, some of the rows contain “#”s next to the number. This indicates that the value results from an extrapolation instead of an experimental result, but adding the “#” does mean that that entry is no longer a number. We need the expected numeric data for later analysis, so the following code cell will force the last four columns to be numeric. This will convert the entries with “#” to “NaN,” which stands for “not a number.” This makes these entries easier to remove.\nThe process shown in this notebook section is quite common when working with physics data sets. But, first, Python must recognize the columns we wish to perform calculations with as numeric values. If you complete this step, it will make much of the later analysis in this notebook possible.\nTo learn more about the to_numeric() function, you can read the documentation here.\nnuclear_data.loc[:,'BE'] = pd.to_numeric(nuclear_data.loc[:,'BE'], errors='coerce')\nnuclear_data.loc[:,'BEd'] = pd.to_numeric(nuclear_data.loc[:,'BEd'], errors='coerce')\nnuclear_data.loc[:,'MASS'] = pd.to_numeric(nuclear_data.loc[:,'MASS'], errors='coerce')\nnuclear_data.loc[:,'MASSd'] = pd.to_numeric(nuclear_data.loc[:,'MASSd'], errors='coerce')\nIf we now print nuclear_data we should see that most of the later data (which previously contained “#”s) should read “NaN”.\nAs we learned last lab, pandas can handle “NaN” when formatted correctly, which this function does.\nnuclear_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.000\n0.0\n1.008665e+06\n0.00049\n\n\n1\n0\n1\n1\nH\n0.000\n0.0\n1.007825e+06\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.0\n2.014102e+06\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.0\n3.016049e+06\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.0\n3.016029e+06\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3431\n176\n117\n293\nEh\nNaN\nNaN\nNaN\nNaN\n\n\n3432\n175\n118\n293\nEi\nNaN\nNaN\nNaN\nNaN\n\n\n3433\n177\n117\n294\nEh\nNaN\nNaN\nNaN\nNaN\n\n\n3434\n176\n118\n294\nEi\nNaN\nNaN\nNaN\nNaN\n\n\n3435\n177\n118\n295\nEi\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n3436 rows × 8 columns\n\n\nPandas makes it very easy to remove “NaN” values from a Dataframe, so now the data will be easy to format. If you are unsure if there are “NaN” values in your Dataframe you can use the below line of code to check. It will return True if any entries in the Dataframe are “NaN”.\nnuclear_data.isnull().values.any()\nTrue\nBefore we remove the “NaN”s, lets print the number of rows in the Dataframe, using the ‘len’ function, to see how many data points we started out with.\nlen(nuclear_data)\n3436\ndropna will remove a row from the Dataframe if any entry in that row is “NaN”. This will reduce the amount of data we have in our Dataframe but it ensures that the remaining data is numeric. You can read more about dropna here.\nnuclear_data = nuclear_data.dropna()\nFinally, let’s print the number of remaining data points and the Dataframe to make sure the data still looks reasonable.\nlen(nuclear_data)\n2498\nnuclear_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.000\n0.000\n1.008665e+06\n0.00049\n\n\n1\n0\n1\n1\nH\n0.000\n0.000\n1.007825e+06\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.000\n2.014102e+06\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.000\n3.016049e+06\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.000\n3.016029e+06\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3305\n156\n108\n264\nHs\n7298.375\n0.109\n2.641284e+08\n31.00500\n\n\n3311\n157\n108\n265\nHs\n7296.247\n0.090\n2.651298e+08\n25.71900\n\n\n3318\n158\n108\n266\nHs\n7298.273\n0.145\n2.661300e+08\n41.54000\n\n\n3339\n159\n110\n269\nDs\n7250.154\n0.117\n2.691448e+08\n33.71200\n\n\n3345\n160\n110\n270\nDs\n7253.775\n0.178\n2.701446e+08\n51.54200\n\n\n\n\n2498 rows × 8 columns\n\n\n\n\n\nAs we learned in the last lab, masks are a way to create a smaller Dataframe where only certain conditions are true. We do this by putting a conditional expression (an expression that evaluates to either True or False) after the name of the Dataframe. Only the rows of the Dataframe that result in a True value will be returned.\nFor example, the following code cell creates a smaller Dataframe called nuclear_data_A_below_60, where entries from nuclear_data are added if they have 60 or fewer nucleons (A).\nA_below_60 = nuclear_data[\"A\"] &lt;= 60\nnuclear_data_A_below_60 = nuclear_data[A_below_60]\nWe can print nuclear_data_A_below_60 in order to ensure that it only gives us entries were A \\(\\leq\\) 60.\nnuclear_data_A_below_60\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.000\n0.000\n1.008665e+06\n0.00049\n\n\n1\n0\n1\n1\nH\n0.000\n0.000\n1.007825e+06\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.000\n2.014102e+06\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.000\n3.016049e+06\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.000\n3.016029e+06\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n543\n34\n26\n60\nFe\n8755.851\n0.057\n5.993407e+07\n3.65900\n\n\n544\n33\n27\n60\nCo\n8746.766\n0.007\n5.993382e+07\n0.45500\n\n\n545\n32\n28\n60\nNi\n8780.774\n0.006\n5.993079e+07\n0.40300\n\n\n546\n31\n29\n60\nCu\n8665.602\n0.027\n5.993736e+07\n1.73600\n\n\n547\n30\n30\n60\nZn\n8583.050\n0.009\n5.994184e+07\n0.60500\n\n\n\n\n428 rows × 8 columns\n\n\nMasks have a variety of uses, and the conditions can be as complicated as needed. For example, the above mask could be extended to separate A \\(\\leq\\) 60 and A \\(\\geq\\) 180. You could create a mask that extracts the isotopes of carbon, oxygen, and nitrogen by filtering for specific values of Z or element symbol.\n\nExercise 5:\nCreate any mask you want and then apply it to the nuclear_data dataframe. Save the results as a new dataframe with a descriptive name. Then, print the new dataframe.\nNow, check with one other classmate. Did you make the same mask? If yes, then together, come up with another mask that does something different. Save the results as a new dataframe with a descriptive name and print the new dataframe.\n\n\nSTOP and do a quick check-in with sli.do – tell us what your mask did! If you and your neighbor made a second mask together, make sure you submit that one, too. You can do that  here.\n\n\n\n\nYou can add new columns to a Pandas dataframe, either taken from a new series, dictionary, or numpy array that you’ve created, or by modifying another column.\nOne thing to consider when using numerical data is what units are associated with the data and whether they are the correct units for further analysis. The binding energies and uncertainties are given in units of keV (kiloelectron volts) per nucleon. By convention, however, binding energies are usually given in units of MeV (megaelectron volts) per nucleon. It is easy to convert keV to MeV simply by dividing by 1000.\nWe can create a new column in the dataframe that uses the units we want. For example, we want to work with the binding energy and its uncertainty in MeV.\nThe binding energy is the column marked “BE” and its uncertainty is “BEd”. Let’s make two new columns, which we will call “BE (MeV)” and “BEd (MeV)” and have the correct units:\nnuclear_data[\"BE (MeV)\"] = nuclear_data[\"BE\"]/1000.\nnuclear_data[\"BEd (MeV)\"] = nuclear_data[\"BEd\"]/1000.\nYou may have just gotten a very scary-looking warning message from Pandas, if you tried to do this with just labels and not using .loc. This warning is trying to let you know that you’re working with copies of data. The documentation linked in the warning is really helpful for understanding what’s happening under the hood, but as can happen sometimes with documentation, the examples provided aren’t necessarily incredibly illuminating for the exact scenario we are working with.\nSo let’s dig a little deeper into how to use .loc to do masking and manipulation:\nHere is the trick: you want to adjust the way we index both the new column and the old column we’re manipulating, using .loc instead of just using the labels. So instead of:\ndf[\"new column name\"] = df[\"old column name\"]/1000.\nwe want\ndf.loc[:,\"new column name\"] = df[:,\"old column name\"]/1000.\nIt’s a small change, but it makes a big difference to ensure that you are correctly indexing and modifying the dataframe. As you learned last time, the .loc method:\ndf.loc[\"row index\",\"column index\"]\nis generally preferred, and as you start to do more complicated things with Pandas, you will want to start using it.\nThe cell below modifies the above code to work without producing the SettingWithCopyWarning (Google it to see how common this is!).\nNOTE you may still get the warning when you run the cell. Run it again and it will go away. I don’t know what is causing this, but I think it is a Jupyter Notebook issue and not a pandas issue.\nnuclear_data.loc[:,\"BE (MeV)\"] = nuclear_data.loc[:,\"BE\"]/1000.\n/opt/jupyterhub/lib/python3.8/site-packages/pandas/core/indexing.py:1667: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  self.obj[key] = value\nnuclear_data.loc[:,\"BEd (MeV)\"] = nuclear_data.loc[:,\"BEd\"]/1000.\n\nNow go back and comment out the original attempt to create a new column. Then restart the kernel and run up to the current cell, just to make sure there are no lingering copies or errors in the dataframe. It’s always good to periodically check that your code runs linearly from the start of the notebook to the end, so that you can reproduce your work!\n\nNext, the mass and its uncertainty are given in terms of \\(\\mu\\)u (micro-atomic units), but it’s easier to have them in atomic units (u). Therefore we multiply the mass and its uncertainty by 1x10\\(^{-6}\\) to get the correct units.\n\nExercise 6:\nCreate a new column that has the mass and the uncertainty of the masses in atomic units by multiplying both mass and mass_uncertainty by 1x10\\(^{-6}\\).\nMake sure you use the .loc method! And make sure you check that your DataFrame looks right when you’re done.\n\n\n\n\nWhile a Pandas Dataframe helps do some of the data formatting and analysis, having the data separated by column is also advantageous, especially regarding some of the data manipulation required for graphing. This section formats the data from our Dataframe to help create graphs.\nYou can extract data from a dataframe and save it as its own variable in Python.\nN = nuclear_data[\"N\"]\nprint(N)\n0         1\n1         0\n2         1\n3         2\n4         1\n       ... \n3305    156\n3311    157\n3318    158\n3339    159\n3345    160\nName: N, Length: 2498, dtype: int64\nIf we print the type of the column we extracted above, we will see that the type is pandas.core.series.Series.\ntype(N)\npandas.core.series.Series\n\nExercise 7:\nExtract the various columns of the Dataframe (as was done above with “N”) and save them using the variable names shown in the below table.\n\n\n\nColumn Name\nVariable Name\n\n\n\n\nN\nN\n\n\nZ\nZ\n\n\nA\nA\n\n\nBE (MeV)\nBE\n\n\nBEd (MeV)\nBE_uncertainty\n\n\nMASS (u)\nmass\n\n\nMASSd (u)\nmass_uncertainty\n\n\n\nYou must use the names specified in the above table, as the rest of the code relies on them.\n\n\nWe’re done with the data manipulation part of this notebook. Check in with  slido and then work on whatever you need to until we’re ready to move on to the plotting part of the notebook."
  },
  {
    "objectID": "SDS271/F23/Lab4_clean.html#introduction-to-data-science-libraries",
    "href": "SDS271/F23/Lab4_clean.html#introduction-to-data-science-libraries",
    "title": "Lab 4: Data Science Libraries in Python",
    "section": "",
    "text": "This notebook will introduce you to three libraries commonly used in data science and help analyze physics data. Pandas (which you have already seen) provide ways to easily import data from a file and save it a Pandas Dataframe, which allows us to easily display the data as a table, access the different columns of data, and begin formatting the data for later analysis. The other two libraries used in this notebook, Seaborn and Matplotlib (which you’ve also seen already), are used to create graphs from the data set. We will learn about Seaborn and dig into more advanced plotting with Matplotlib in this lab. Each graphing library has its strengths and reasons to use, which will be discussed later in the notebook.\nIt maybe easier to think about these libraries by thinking about their relationships to each other. NumPy, one of the standard Python libraries, provides an implementation of a data structure called arrays, which allows us to easily manipulate one and two dimensional data sets. However, it can be hard to display a matrix of data and extract different column, especially since NumPy does not provide headers for its columns. Pandas is simply a wrapper for NumPy arrays which provides an easy way to display, access, and manipulate two dimensional data sets. However, underneath the hood it is simply using NumPy arrays.\nLikewise, Matplotlib is the simplest graphing library avaliable in Python and its default graphs are quite plain. Seaborn is a wrapper of the Matplotlib class which adds more formatting to the default graphs and also provides the creation of some compound graphs, such as pairplot that we will look at below."
  },
  {
    "objectID": "SDS271/F23/Lab4_clean.html#introduction-to-the-data-set",
    "href": "SDS271/F23/Lab4_clean.html#introduction-to-the-data-set",
    "title": "Lab 4: Data Science Libraries in Python",
    "section": "",
    "text": "The data set we will investigate in this notebook contains the following data for every measurable isotope: number of neutrons, number of protons, number of nucleons, binding energy, the uncertainty of binding energy measurement, atomic mass, and uncertainty on mass measurement. This notebook section will help you better understand this data set and why nuclear scientists may want to study it.\n\n\nThe nucleus of an atom contains two types of particles: positively charged particles called protons and neutral particles called neutrons. The total number of protons in the nucleus is Z, and the total number of neutrons is N. Protons and neutrons are both types of nucleons, so the total number of nucleons in the nucleus is A = Z + N.\nThe number of protons in the nucleus determines what element it is. For example, all nuclei with 12 protons are carbon nuclei, all nuclei with 1 proton are hydrogen, and all nuclei with 20 protons are calcium. However, the number of neutrons in a nucleus does not define an element. So there are carbon atoms with 11 neutrons, 12 neutrons, 13 neutrons, and so on. Nuclei that have the same number of protons but different numbers of neutrons are referred to as isotopes of each other.\n\n\n\nAn atom’s atomic mass is the atom’s total mass (i.e., the nucleus and the protons). Note that it is not the same as the sum of the masses of the particles that make up the atom. This will be explored in the next section.\n\n\n\nThe mass of an atomic nucleus will be less than the total mass of its constituent particles. This difference in mass is called the binding energy, as it is the energy required to hold the atom together. Remember that mass and energy are related by the famous equation from Einstein: \\(E = mc^2\\).\nTo calculate the theoretical binding energies using Einstein’s equation, we can define the binding energy as:\n\\[BE = Mc^2 - mc^2,\\]\nwhere M is the total mass of all of the particles in the atom, m is the actual atomic mass of the atom, and c is the speed of light in a vacuum. We can define M as:\n\\[M = Z(m_p + m_e) + Nm_n,\\]\nwhere m\\(_p\\) is the mass of a proton, m\\(_e\\) is the mass of an electron, and m\\(_n\\) is the mass of a neutron. So, we can rewrite the binding energy as:\n\\[BE = ((m_p + m_e)Z + m_nN - m)c^2.\\]\nNext, we can define the atomic mass of hydrogen as one proton plus one electron: \\[m_h = m_p + m_e,\\]\nwhich means we can rewrite the binding energy as:\n\\[BE = (m_hZ + m_nN - m)c^2,\\]\nwhere \\(m_h\\) = 1.007 MeV, \\(m_n\\) = 1.008 MeV and \\(c^2\\) = 931.49 MeV/u.\nThe binding energies in the data set are experimental binding energies. Later in this notebook, we will determine how well the experimental binding energies correspond to the theoretical ones we defined in this section.\n\n\n\nThe atomic masses and binding energies in this data set were collected through experiments. Any data collected through experimentation has uncertainty in it. Though these are usually relatively small, they are also presented in this data set."
  },
  {
    "objectID": "SDS271/F23/Lab4_clean.html#imports",
    "href": "SDS271/F23/Lab4_clean.html#imports",
    "title": "Lab 4: Data Science Libraries in Python",
    "section": "",
    "text": "Exercise 1: Import the following packages that you’ve already seen to this notebook:\n\n\nnumpy (as np)\n\n\npyplot from matplotlib (as plt)\n\n\npandas (as pd)\n\n\n\n\nThe data set is saved in the file “NuclearData.tsv”, which you can find in Moodle. Upload that file to the same directory in JupyterHub where you have this notebook saved.\nWe’re going to read in this data using the read_csv() function that you used in the last lab. But note that the data is a “.tsv” file, which means the data is separated by tabs and not commas.\n\nExercise 2:\nRead the documentation for the  read_csv() function and figure out what you need to do to make this work for a tab-separated file. Then, import the data into a dataframe – call this dataframe “nuclear_data” as we will be working with a mix of examples and exercises and it will be easiest if we all use the same name.\nHint: remember the regex shorthands you learned in SDS 192.\n\nFirst, lets confirm that nuclear_data is a Pandas Dataframe by printing its type.\ntype(nuclear_data)\npandas.core.frame.DataFrame\nNow lets print nuclear_data to see what the DataFrame looks like.\nNote, you can also print just the head() or tail(), and if you have a very large DataFrame, it will be easier to do that if you just want to see the basic structure. But let’s go ahead and print the whole thing.\nnuclear_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.0\n0.0\n1008664.91582\n0.00049\n\n\n1\n0\n1\n1\nH\n0.0\n0.0\n1007825.03224\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.000\n2014101.77811\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.000\n3016049.28199\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.000\n3016029.32265\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3431\n176\n117\n293\nEh\n7095#\n3#\n293208680#\n870#\n\n\n3432\n175\n118\n293\nEi\n7077#\n2#\n293213498#\n753#\n\n\n3433\n177\n117\n294\nEh\n7092#\n2#\n294210974#\n708#\n\n\n3434\n176\n118\n294\nEi\n7079#\n2#\n294214132#\n712#\n\n\n3435\n177\n118\n295\nEi\n7075#\n2#\n295216332#\n692#\n\n\n\n\n3436 rows × 8 columns\n\n\nA DataFrame allows us to easily display the different columns and rows of the data file in a table. It even used the column labels from the data file to name the other columns.\nThe columns from left to right are the number of neutrons, number of protons, number of nucleons (i.e., the total number of protons and neutrons or A = N+Z), the elemental symbol, the binding energy per nucleon, the uncertainty on the binding energy, the atomic mass, and the uncertainty on the atomic mass.\n\n\n\nA Pandas Dataframe can behave like a dictionary where the column headings are the keys, and the columns are the values.\nLast lab, we used .columns to print the columns, but we can do this another way as well, using the .keys() function, just like with a dictionary.\nWhy bother with two actions that do the same thing? A Pandas dataframe is an object, which means it has attributes and built in functions. Things like .columns and .shape return attributes of the object, while things like .keys() and .head() perform some action defined by an internal function.\n\nExercise 3:\nPrint the list of the columns in this dataframe using both methods: .columns and .keys() and verify that they give you the same thing.\n\n\nExercise 4:\nExplore accessing the various columns of data using the column headers. Make sure you can access all of the different columns.\n\n\n\n\nAfter a data set is imported, we need to start formatting it so it’s ready for analysis. Most of the time, this will include ensuring the data is the correct type (i.e., numeric or words) and that every entry in the Dataframe is filled out. Every column of the Dataframe should be numeric except for the element symbol. However, when nuclear_data is printed, some of the rows contain “#”s next to the number. This indicates that the value results from an extrapolation instead of an experimental result, but adding the “#” does mean that that entry is no longer a number. We need the expected numeric data for later analysis, so the following code cell will force the last four columns to be numeric. This will convert the entries with “#” to “NaN,” which stands for “not a number.” This makes these entries easier to remove.\nThe process shown in this notebook section is quite common when working with physics data sets. But, first, Python must recognize the columns we wish to perform calculations with as numeric values. If you complete this step, it will make much of the later analysis in this notebook possible.\nTo learn more about the to_numeric() function, you can read the documentation here.\nnuclear_data.loc[:,'BE'] = pd.to_numeric(nuclear_data.loc[:,'BE'], errors='coerce')\nnuclear_data.loc[:,'BEd'] = pd.to_numeric(nuclear_data.loc[:,'BEd'], errors='coerce')\nnuclear_data.loc[:,'MASS'] = pd.to_numeric(nuclear_data.loc[:,'MASS'], errors='coerce')\nnuclear_data.loc[:,'MASSd'] = pd.to_numeric(nuclear_data.loc[:,'MASSd'], errors='coerce')\nIf we now print nuclear_data we should see that most of the later data (which previously contained “#”s) should read “NaN”.\nAs we learned last lab, pandas can handle “NaN” when formatted correctly, which this function does.\nnuclear_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.000\n0.0\n1.008665e+06\n0.00049\n\n\n1\n0\n1\n1\nH\n0.000\n0.0\n1.007825e+06\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.0\n2.014102e+06\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.0\n3.016049e+06\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.0\n3.016029e+06\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3431\n176\n117\n293\nEh\nNaN\nNaN\nNaN\nNaN\n\n\n3432\n175\n118\n293\nEi\nNaN\nNaN\nNaN\nNaN\n\n\n3433\n177\n117\n294\nEh\nNaN\nNaN\nNaN\nNaN\n\n\n3434\n176\n118\n294\nEi\nNaN\nNaN\nNaN\nNaN\n\n\n3435\n177\n118\n295\nEi\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n3436 rows × 8 columns\n\n\nPandas makes it very easy to remove “NaN” values from a Dataframe, so now the data will be easy to format. If you are unsure if there are “NaN” values in your Dataframe you can use the below line of code to check. It will return True if any entries in the Dataframe are “NaN”.\nnuclear_data.isnull().values.any()\nTrue\nBefore we remove the “NaN”s, lets print the number of rows in the Dataframe, using the ‘len’ function, to see how many data points we started out with.\nlen(nuclear_data)\n3436\ndropna will remove a row from the Dataframe if any entry in that row is “NaN”. This will reduce the amount of data we have in our Dataframe but it ensures that the remaining data is numeric. You can read more about dropna here.\nnuclear_data = nuclear_data.dropna()\nFinally, let’s print the number of remaining data points and the Dataframe to make sure the data still looks reasonable.\nlen(nuclear_data)\n2498\nnuclear_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.000\n0.000\n1.008665e+06\n0.00049\n\n\n1\n0\n1\n1\nH\n0.000\n0.000\n1.007825e+06\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.000\n2.014102e+06\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.000\n3.016049e+06\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.000\n3.016029e+06\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3305\n156\n108\n264\nHs\n7298.375\n0.109\n2.641284e+08\n31.00500\n\n\n3311\n157\n108\n265\nHs\n7296.247\n0.090\n2.651298e+08\n25.71900\n\n\n3318\n158\n108\n266\nHs\n7298.273\n0.145\n2.661300e+08\n41.54000\n\n\n3339\n159\n110\n269\nDs\n7250.154\n0.117\n2.691448e+08\n33.71200\n\n\n3345\n160\n110\n270\nDs\n7253.775\n0.178\n2.701446e+08\n51.54200\n\n\n\n\n2498 rows × 8 columns\n\n\n\n\n\nAs we learned in the last lab, masks are a way to create a smaller Dataframe where only certain conditions are true. We do this by putting a conditional expression (an expression that evaluates to either True or False) after the name of the Dataframe. Only the rows of the Dataframe that result in a True value will be returned.\nFor example, the following code cell creates a smaller Dataframe called nuclear_data_A_below_60, where entries from nuclear_data are added if they have 60 or fewer nucleons (A).\nA_below_60 = nuclear_data[\"A\"] &lt;= 60\nnuclear_data_A_below_60 = nuclear_data[A_below_60]\nWe can print nuclear_data_A_below_60 in order to ensure that it only gives us entries were A \\(\\leq\\) 60.\nnuclear_data_A_below_60\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nN\nZ\nA\nEL\nBE\nBEd\nMASS\nMASSd\n\n\n\n\n0\n1\n0\n1\nn\n0.000\n0.000\n1.008665e+06\n0.00049\n\n\n1\n0\n1\n1\nH\n0.000\n0.000\n1.007825e+06\n0.00009\n\n\n2\n1\n1\n2\nH\n1112.283\n0.000\n2.014102e+06\n0.00012\n\n\n3\n2\n1\n3\nH\n2827.265\n0.000\n3.016049e+06\n0.00023\n\n\n4\n1\n2\n3\nHe\n2572.680\n0.000\n3.016029e+06\n0.00022\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n543\n34\n26\n60\nFe\n8755.851\n0.057\n5.993407e+07\n3.65900\n\n\n544\n33\n27\n60\nCo\n8746.766\n0.007\n5.993382e+07\n0.45500\n\n\n545\n32\n28\n60\nNi\n8780.774\n0.006\n5.993079e+07\n0.40300\n\n\n546\n31\n29\n60\nCu\n8665.602\n0.027\n5.993736e+07\n1.73600\n\n\n547\n30\n30\n60\nZn\n8583.050\n0.009\n5.994184e+07\n0.60500\n\n\n\n\n428 rows × 8 columns\n\n\nMasks have a variety of uses, and the conditions can be as complicated as needed. For example, the above mask could be extended to separate A \\(\\leq\\) 60 and A \\(\\geq\\) 180. You could create a mask that extracts the isotopes of carbon, oxygen, and nitrogen by filtering for specific values of Z or element symbol.\n\nExercise 5:\nCreate any mask you want and then apply it to the nuclear_data dataframe. Save the results as a new dataframe with a descriptive name. Then, print the new dataframe.\nNow, check with one other classmate. Did you make the same mask? If yes, then together, come up with another mask that does something different. Save the results as a new dataframe with a descriptive name and print the new dataframe.\n\n\nSTOP and do a quick check-in with sli.do – tell us what your mask did! If you and your neighbor made a second mask together, make sure you submit that one, too. You can do that  here.\n\n\n\n\nYou can add new columns to a Pandas dataframe, either taken from a new series, dictionary, or numpy array that you’ve created, or by modifying another column.\nOne thing to consider when using numerical data is what units are associated with the data and whether they are the correct units for further analysis. The binding energies and uncertainties are given in units of keV (kiloelectron volts) per nucleon. By convention, however, binding energies are usually given in units of MeV (megaelectron volts) per nucleon. It is easy to convert keV to MeV simply by dividing by 1000.\nWe can create a new column in the dataframe that uses the units we want. For example, we want to work with the binding energy and its uncertainty in MeV.\nThe binding energy is the column marked “BE” and its uncertainty is “BEd”. Let’s make two new columns, which we will call “BE (MeV)” and “BEd (MeV)” and have the correct units:\nnuclear_data[\"BE (MeV)\"] = nuclear_data[\"BE\"]/1000.\nnuclear_data[\"BEd (MeV)\"] = nuclear_data[\"BEd\"]/1000.\nYou may have just gotten a very scary-looking warning message from Pandas, if you tried to do this with just labels and not using .loc. This warning is trying to let you know that you’re working with copies of data. The documentation linked in the warning is really helpful for understanding what’s happening under the hood, but as can happen sometimes with documentation, the examples provided aren’t necessarily incredibly illuminating for the exact scenario we are working with.\nSo let’s dig a little deeper into how to use .loc to do masking and manipulation:\nHere is the trick: you want to adjust the way we index both the new column and the old column we’re manipulating, using .loc instead of just using the labels. So instead of:\ndf[\"new column name\"] = df[\"old column name\"]/1000.\nwe want\ndf.loc[:,\"new column name\"] = df[:,\"old column name\"]/1000.\nIt’s a small change, but it makes a big difference to ensure that you are correctly indexing and modifying the dataframe. As you learned last time, the .loc method:\ndf.loc[\"row index\",\"column index\"]\nis generally preferred, and as you start to do more complicated things with Pandas, you will want to start using it.\nThe cell below modifies the above code to work without producing the SettingWithCopyWarning (Google it to see how common this is!).\nNOTE you may still get the warning when you run the cell. Run it again and it will go away. I don’t know what is causing this, but I think it is a Jupyter Notebook issue and not a pandas issue.\nnuclear_data.loc[:,\"BE (MeV)\"] = nuclear_data.loc[:,\"BE\"]/1000.\n/opt/jupyterhub/lib/python3.8/site-packages/pandas/core/indexing.py:1667: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  self.obj[key] = value\nnuclear_data.loc[:,\"BEd (MeV)\"] = nuclear_data.loc[:,\"BEd\"]/1000.\n\nNow go back and comment out the original attempt to create a new column. Then restart the kernel and run up to the current cell, just to make sure there are no lingering copies or errors in the dataframe. It’s always good to periodically check that your code runs linearly from the start of the notebook to the end, so that you can reproduce your work!\n\nNext, the mass and its uncertainty are given in terms of \\(\\mu\\)u (micro-atomic units), but it’s easier to have them in atomic units (u). Therefore we multiply the mass and its uncertainty by 1x10\\(^{-6}\\) to get the correct units.\n\nExercise 6:\nCreate a new column that has the mass and the uncertainty of the masses in atomic units by multiplying both mass and mass_uncertainty by 1x10\\(^{-6}\\).\nMake sure you use the .loc method! And make sure you check that your DataFrame looks right when you’re done.\n\n\n\n\nWhile a Pandas Dataframe helps do some of the data formatting and analysis, having the data separated by column is also advantageous, especially regarding some of the data manipulation required for graphing. This section formats the data from our Dataframe to help create graphs.\nYou can extract data from a dataframe and save it as its own variable in Python.\nN = nuclear_data[\"N\"]\nprint(N)\n0         1\n1         0\n2         1\n3         2\n4         1\n       ... \n3305    156\n3311    157\n3318    158\n3339    159\n3345    160\nName: N, Length: 2498, dtype: int64\nIf we print the type of the column we extracted above, we will see that the type is pandas.core.series.Series.\ntype(N)\npandas.core.series.Series\n\nExercise 7:\nExtract the various columns of the Dataframe (as was done above with “N”) and save them using the variable names shown in the below table.\n\n\n\nColumn Name\nVariable Name\n\n\n\n\nN\nN\n\n\nZ\nZ\n\n\nA\nA\n\n\nBE (MeV)\nBE\n\n\nBEd (MeV)\nBE_uncertainty\n\n\nMASS (u)\nmass\n\n\nMASSd (u)\nmass_uncertainty\n\n\n\nYou must use the names specified in the above table, as the rest of the code relies on them.\n\n\nWe’re done with the data manipulation part of this notebook. Check in with  slido and then work on whatever you need to until we’re ready to move on to the plotting part of the notebook."
  },
  {
    "objectID": "SDS271/F23/Lab4_clean.html#exploratory-plotting-with-seaborn",
    "href": "SDS271/F23/Lab4_clean.html#exploratory-plotting-with-seaborn",
    "title": "Lab 4: Data Science Libraries in Python",
    "section": "Exploratory plotting with Seaborn",
    "text": "Exploratory plotting with Seaborn\n\nPairplot\nThe Seaborn function pairplot allows you to plot every column of your Pandas Dataframe against every other column, creating a matrix of graphs. pairplot is useful when you are working with a data set that you are unfamiliar with because it can help you see the patterns within your data and figure out which of the relationships you should analyze further. You can read more about pairplot here.\n\nWarning: The pairplot cells below will take a while each to run due to the amount of data being graphed. Be patient!\n\nsns.pairplot(nuclear_data)\n&lt;seaborn.axisgrid.PairGrid at 0x7f624fe9b280&gt;\n\n\nSTOP and check-in with  sli.do. We are going to discuss what we see here before moving on.\n\n\n\nPairplot with Hue\nIf your data comes with labels for different classes, creating a pairplot is possible where the labels will be different colors. This is accomplished by setting the hue attribute equal to the column name containing the label. For the case of this nuclear data set, plotting the data such that each element is a different color may be helpful. This element symbol column (“EL”) is our label. The below code cell creates a pairplot using the Dataframe only containing data with A \\(\\leq\\) 60 (to reduce the number of points). When a value of hue is passed, it automatically creates a legend on the side of the graph with the different labels.\nsns.pairplot(nuclear_data_A_below_60,hue=\"EL\")\n&lt;seaborn.axisgrid.PairGrid at 0x7f623a3cf280&gt;\n\n\nExercise 9:\nCreate a pairplot with the masked Dataframe you created in Exercise 5. Set the hue attribute to a relevant value for your Dataframe. The element symbols may make the most sense or another column depending on the mask you applied.\n\nBesides pairplot, Seaborn contains a variety of helpful plotting tools. See some examples of graphs in this gallery. The nice thing about Seaborn is that the graphs come preformatted with labels and legends, and color scales. This can be nice for saving time, but it does take some of the customizations out of the process. The following library we will investigate, Matplotlib, provides a lot of customization for the graphs, but it all must be done manually instead of using prebuilt style guides.\n\n\nPlotting a relationship\nFor the next section of this notebook, we will focus on the graph of binding energy as a function of A as this graph has quite a bit of importance in nuclear physics and engineering, so displaying it in a pleasing and easy-to-understand manner is essential.\n\n\nRegplot\nAnother important Seaborn plot is regplot which is a scatterplot. It takes three main arguments: the Pandas Dataframe, the name of the column to plot on the x axis, and the name of the column to plot on the y axis. In the below example we have also used the argument fit_reg and set it to False. If this is not done then Seaborn will attempt to create a line of best fit for the data being plotted. However, a line is obviously not the best fit for this graph so we will leave it off of the plot. There are many other arguments that can be used to format this plot and the documentation can be found here.\nsns.regplot(data=nuclear_data, x=\"N\", y=\"BE\", fit_reg=False)\n&lt;AxesSubplot:xlabel='N', ylabel='BE'&gt;\n\nregplot is simply a Seaborn wrapper for the Matplotlib function plot.scatter which will be investigated later in this notebook. While the regplot graph looks decent by default (come back and compare this graph to the first plt.scatter plot we will create below) it is much harder to make changes and personalize the graph when we compare it ot the Matplotlib library we will look at next.\n\nExercise 10:\nUse regplot to create a plot using your masked Dataframe. You can use your above pairplot to decide which graph will be the most interesting. Play around with the different arguments found in the documentation until you have a graph you are happy with.\n\n\n\nCurve_fit\nThe problem with regplot is that there’s no way to get the function it fit. You can see the line, but you don’t know its slope. What if you wanted to know how steep this relationship is? You need another option.\nThe function you need here is curve_fit, which is in the package scipy.\nYou can import the whole scipy package, but it’s faster and easier to select just curve fit\nfrom scipy.optimize import curve_fit\n\nExercise 11:\n\nImport curve_fit:\nDefine a linear function\nSelect your x and y data from the dataframe\nRun the curve fit and look at the parameters it returned.\n\nWe will talk about plotting these results in the next section."
  },
  {
    "objectID": "SDS271/F23/Lab4_clean.html#conclusion",
    "href": "SDS271/F23/Lab4_clean.html#conclusion",
    "title": "Lab 4: Data Science Libraries in Python",
    "section": "Conclusion",
    "text": "Conclusion\nIn this notebook, we have explored how the three libraries Pandas, Seaborn, and Matplotlib can be used to examine and display a data set. These libraries have many applications across data science and other fields, and you will encounter them many times while using Python.\nThis was a LOT! I hope you feel as cool as Joe MacMillan thinks he is."
  },
  {
    "objectID": "SDS271/F23/Lab4_clean.html#further-resources",
    "href": "SDS271/F23/Lab4_clean.html#further-resources",
    "title": "Lab 4: Data Science Libraries in Python",
    "section": "Further Resources",
    "text": "Further Resources\nIf you want to learn more about any of the libraries presented here, the websites for each library are a great place to start.\n\nPandas website\nGetting Started with Pandas\nSeaborn website\nSeaborn Examples\nSeaborn User Guide and Tutorials\nMatplotlib website\nMatplotlib Examples\nMatplotlib Tutorials\n\n\nCheck-in with  sli.do. Then feel free to continue with the extended practice or work on your own projects."
  },
  {
    "objectID": "index.html#facilitating-learning",
    "href": "index.html#facilitating-learning",
    "title": "Casey E Berger",
    "section": "Facilitating learning",
    "text": "Facilitating learning\n\nInclusive Classrooms\nTeaching Philosophy"
  },
  {
    "objectID": "index.html#equity-in-stem",
    "href": "index.html#equity-in-stem",
    "title": "Casey E Berger",
    "section": "Equity in STEM",
    "text": "Equity in STEM\n\n\n\n\n\n\n\n\n\nAcademia in general and STEM fields in particular have a long way to go towards creating a welcoming environment where women, LGBTQ folks, BIPOC, and other underrepresented groups can thrive. We all have a responsibility to listen, learn, and be part of the solution.\n\n\n\n\nResources for Equity in STEM"
  },
  {
    "objectID": "index.html#professional-development-resources",
    "href": "index.html#professional-development-resources",
    "title": "Casey E Berger",
    "section": "Professional Development Resources",
    "text": "Professional Development Resources\nOur education – especially those of us in STEM – focuses on content and skill building in a narrow, deep area of interest. Rarely are we explicitly taught the so-called “soft skills” of communication and teamwork and problem solving and creative thinking, let alone the “life management” skills of time tracking, prioritization, and finding room for rest and recovery.\nI’ve assembled here a set of tools and resources for effective work and a reflective life.\n\nResources for Professional Skill Building"
  },
  {
    "objectID": "cv_and_pubs.html#doctoral-dissertation",
    "href": "cv_and_pubs.html#doctoral-dissertation",
    "title": "CV and Publications",
    "section": "Doctoral Dissertation",
    "text": "Doctoral Dissertation\nCircumventing the sign problem in rotating quantum matter, C. E. Berger, Doctoral Dissertation, UNC Chapel Hill. ProQuest - (2020)\n\n\n\n\nProQuest",
    "crumbs": [
      "CV and Publications"
    ]
  },
  {
    "objectID": "cv_and_pubs.html#publications-and-preprints",
    "href": "cv_and_pubs.html#publications-and-preprints",
    "title": "CV and Publications",
    "section": "Publications and Preprints",
    "text": "Publications and Preprints\nQuantum technologies for climate change: Preliminary assessment, C. E. Berger, A. Di Paolo, T. Forrest, S. Hadfield, N. Sawaya, M. Stęchły, and K. Thibault, ArXiv pre-print, July 2021\n\n\nArXiV\nComplex Langevin and other approaches to the sign problem in quantum many-body physics, C. E. Berger, L. Rämmelmuller, A. C. Loheac, F. Ehmann, J. Braun, and J. E. Drut, Physics Reports, Vol 892, ISSN 0370-1573, January 2021\n\n\nDOI\nArXiV\nThermodynamics of rotating quantum matter in the virial expansion, C. E. Berger, K.J. Morrell, and J. E. Drut. Physical Review A, 102, 023309, August 2020\n\n\nDOI\nArXiV\nThird- and fourth-order virial coefficients of harmonically-trapped fermions in a semi-classical approximation, K. J. Morrell, C. E. Berger, and J. E. Drut. Physical Review A, 100, 063626, December 2019\n\n\nDOI\nArXiV\nInteracting bosons at finite angular momentum via complex Langevin, C. E. Berger and J. E. Drut, Proceedings of the 36th Annual International Symposium on Lattice Field Theory (2019)\n\n\nDOI\nHard-wall and non-uniform lattice Monte Carlo approaches to one-dimensional Fermi gases in a harmonic trap, C. E. Berger, J. E. Drut, and W. J. Porter. Computer Physics Communications 208, pp. 103-108 (2016)\n\n\nDOI\nArXiV\nHarmonically trapped fermions in two dimensions: ground-state energy and contact of SU(2 ) and SU(4 ) systems via nonuniform lattice Monte Carlo, Z-H. Luo, C. E. Berger, and J. E. Drut, Phys. Rev. A 93, 033604 - (2016)\n\n\nDOI\nArXiV\nEnergy, contact, and density profiles of one-dimensional fermions in a harmonic trap via nonuniform-lattice Monte Carlo calculations, C. E. Berger, E. R. Anderson, and J. E. Drut, Phys. Rev. A 91, 053618 - (2015)\n\n\nDOI\nArXiV",
    "crumbs": [
      "CV and Publications"
    ]
  }
]